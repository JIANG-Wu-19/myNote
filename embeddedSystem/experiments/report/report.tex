\documentclass[UTF8,12pt]{article}
\usepackage{ctex}
\usepackage{indentfirst}
\usepackage{color}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{pdfpages}
\usepackage{listings}
\usepackage{afterpage}
\usepackage{geometry}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{graphicx}
\usepackage{tabularray}

\geometry{a4paper,scale=0.8}

\newcommand\myemptypage{
    \null
    \thispagestyle{empty}
    \addtocounter{page}{-1}
    \newpage
}

\hypersetup{
    hidelinks,
	colorlinks=true,
	allcolors=black,
	pdfstartview=Fit,
	breaklinks=true
}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{ %
  language=Octave,                % the language of the code
  basicstyle=\footnotesize,           % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  stepnumber=2,                   % the step between two line-numbers. If it's 1, each line 
                                  % will be numbered
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},      % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=2,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                   % show the filename of files included with \lstinputlisting;
                                  % also try caption instead of title
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{dkgreen},       % comment style
  stringstyle=\color{mauve},         % string literal style
  escapeinside={\%*}{*)},            % if you want to add LaTeX within your code
  morekeywords={*,...}               % if you want to add more keywords to the set
}


\setlength{\parindent}{2em}

\begin{document}

\begin{titlepage}
    \includepdf[pages={1}]{cover.pdf}
\end{titlepage}

\myemptypage

\begin{center}
    \tableofcontents
\end{center}

\newpage

\section{实验1《GPIO端口实验》}

实验学时：2

每组人数：3

实验类别：2\ （1：基础性\ 2：综合性\ 3：设计性\ 4：研究性）

实验要求：1\ （1：必修\ 2：选修\ 3：其它）

实验类别：3\ （1：基础\ 2：专业基础\ 3：专业\ 4：其它）

\subsection{实验目的}
\begin{enumerate}
    \item 熟悉并掌握Keil MDK开发环境的使用以及在线调试方法；
    \item 掌握STM32F746NG芯片GPIO端口寄存器的配置；
    \item 通过实验掌握Cortex-M7控制GPIO端口的方法，实现对LED的控制。
\end{enumerate}

\subsection{实验内容}
编写程序，对指定GPIO端口进行初始化并完成配置过程，实现对LED的控制。学习使用超级终端，对其进行配置并完成串口调试。实验中观察GPIO端口输出数据寄存器（GPIOx\_ODR）的值对LED灯的明灭的影响，学习GPIO端口的输入输出方式、输出类型和输出速度的设置方法。

\subsection{实验方法}

\subsubsection{实验原理}
STM32F746NG芯片共有168个GPIO（通用I/O）端口（GPIOA~GPIOK），每个GPIO端口均可以通过软件配置为输出、输入或复用功能。

\begin{enumerate}
    \item GPIO主要特性
    \begin{itemize}
        \item 输出状态：推挽或开漏+上拉/下拉；
        \item 从输出数据寄存器（GPIOx\_ODR）或外设（复用功能输出）输出数据；
        \item 可为每个I/O选择不同的速度；
        \item 输入状态：浮空、上拉/下拉、模拟；
        \item 将数据输入到输入数据寄存器（GPIOx\_ODR）或外设（复用功能输入）；
        \item 置位和复位寄存器（GPIOx\_BSRR），对GPIOx\_ODR具有按位写权限；
        \item 锁定机制（GPIOx\_LCKR），可冻结I/O端口配置；
        \item 模拟功能；
        \item 复用功能选择寄存器；
        \item 快速翻转，每次翻转最快只需要两个时钟周期；
        \item 引脚复用非常灵活，允许将I/O引脚用作GPIO或多种外设功能中的一种。
    \end{itemize}
    \item GPIO功能描述

    每个GPIO端口的各个端口位均可以自由编程，通过对相关寄存器的修改可以配置为多种模式：
    \begin{itemize}
        \item 浮空输入
        \item 上拉输入
        \item 下拉输入
        \item 模拟输入/输出
        \item 具有上拉或下拉功能的开漏输出
        \item 具有上拉或下拉功能的推挽输出
        \item 具有上拉或下拉功能的复用功能推挽
        \item 具有上拉或下拉功能的复用功能开漏
    \end{itemize}
    对I/O端口进行编程作为输入时，输出缓冲器被禁止，施密特触发器输入被打开，根据GPIOx\_PUPDR寄存器中的值决定是否打开上拉和下拉电阻，输入数据寄存器每隔1个AHB时钟周期对I/O引脚上的数据进行一次采样，对输入数据寄存器的读访问可获取I/O状态。

    对I/O端口进行编程作为输出时，输出缓冲器被打开，施密特触发器输入被打开，根据GPIOx\_PUPDR寄存器中的值决定是否打开上拉和下拉电阻，输入数据寄存器每隔1个AHB时钟周期对I/O引脚上的数据进行一次采样，对输入数据寄存器的读访问可获取I/O状态，对输出数据寄存器的读访问可获取最后的写入值。

    对I/O端口进行编程作为复用功能时，可将输出缓冲器配置为开漏或推挽模式，输出缓冲器由来自外设的信号驱动，施密特触发器输入被打开，根据GPIOx\_PUPDR寄存器中的值决定是否打开上拉和下拉电阻，输入数据寄存器每隔1个AHB时钟周期对I/O引脚上的数据进行一次采样，对输入数据寄存器的读访问可获取I/O状态。

    对I/O端口进行编程作为模拟配置时，输出缓冲器被禁止，施密特触发器输入停用，I/O引脚的每个模拟输入的功耗变为零，施密特触发器的输出被强制处理为恒定值（0），弱上拉和下拉电阻被硬件关闭，对输入数据寄存器的读访问值为“0”。

    \item GPIO寄存器

    每个通用I/O端口包括4个32位配置寄存器（GPIOx\_MODER、GPIOx\_OTYPER、GPIOx\_OSPEEDR 和 GPIOx\_PUPDR）、2个32位数据寄存器（GPIOx\_IDR 和 GPIOx\_ODR）和1个32位置位/复位寄存器 (GPIOx\_BSRR)。此外，所有GPIO都包括1个32位锁定寄存器 (GPIOx\_LCKR) 和2个32位复用功能选择寄存器（GPIOx\_AFRH 和 GPIOx\_AFRL）。I/O端口寄存器必须按32位字、半字或字节进行访问。
    \item GPIO寄存器边界地址
    
    STM43F746NG的GPIO寄存器边界地址如表所示
    \begin{table}[!ht]
        \centering
        \begin{tabular}{|l|l|}
        \hline
            外设 & 寄存器边界地址  \\ \hline
            GPIOA & 0x4002 0000 – 0x4002 03FF  \\ \hline
            GPIOB & 0x4002 0400 – 0x4002 07FF  \\ \hline
            GPIOC & 0x4002 0800 – 0x4002 0BFF  \\ \hline
            GPIOD & 0x4002 0C00 – 0x4002 0FFF  \\ \hline
            GPIOE & 0x4002 1000 – 0x4002 13FF  \\ \hline
            GPIOF & 0x4002 1400 – 0x4002 17FF  \\ \hline
            GPIOG & 0x4002 1800 – 0x4002 1BFF  \\ \hline
            GPIOH & 0x4002 1C00 – 0x4002 1FFF  \\ \hline
            GPIOI & 0x4002 2000 – 0x4002 23FF  \\ \hline
        \end{tabular}
    \end{table}

    \item 实验电路
    
    实验电路如图所示

    \begin{figure}[htbp]
        \centering
        \includegraphics[width=0.8\textwidth]{imgs/1.jpg}
        \caption{实验电路}
    \end{figure}

    如图中所示，U3A单元为STM32F746芯片，发光二极管D1一端与VCC相连，另一端经过1K电阻与Cortex-M7的PA8（GPIOA8）相连，将PA8配置为输出I/O口，即可通过控制其高低电平状态进而控制发光二极管D1的的亮与灭。当PA8输出低电平时，电路导通，发光二极管D1点亮；反之，发光二极管D1熄灭。实验例程中，每次对PA8的输出状态取反后调用延时函数，使发光二极管保持亮或灭，循环往复即可实现发光二极管的闪烁。通过修改延时长度，可以改变发光二极管的闪烁频率。

\end{enumerate}

\subsubsection{实验方案及调试过程}
\noindent
\textbf{基础实验}：首先复现例程代码，得到指导书期望现象并记录
\noindent
实验例程如下：

\begin{lstlisting}[frame=shadowbox]
    /**
    主程序：系统上电初始化后对GPIO中的PA8进行配置，将其配置为输出端口并控制LED闪烁。
  **/
  #include "main.h"
  #include "system_init.h"
  
  /* Private variables */
  uint16_t delay = 100;
  
  void System_Init(void);
  void GPIO_Config(void);
  
  /* main */
  int main(void)
  {
    System_Init();
    
    GPIO_Config();
    
    printf("\n\rExample finished\n\r");
      
    /* Toggle IOs in an infinite loop */
    while (1)
    {
      HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_8);
      /* Insert delay */
      HAL_Delay(delay);
    }
  }  
\end{lstlisting}
调试过程如下：

首先定义了私有变量delay，用于控制延时时间：uint16\_t delay = 100;

然后调用System\_Init()函数进行系统初始化，调用GPIO\_Config()函数对GPIO端口进行初始化。

\begin{lstlisting}[frame=shadowbox]
void System_Init(void)
{
  /* Enable the CPU Cache */
  CPU_CACHE_Enable();

  /* STM32F7xx HAL library initialization */
  HAL_Init();

  /* Configure the system clock to 216 MHz */
  SystemClock_Config();
  
  /* Configure UART */
  UART_Config();
  
  printf("\n\rSystem initialize success\n\r");
}
\end{lstlisting}
GPIO\_Config()函数的定义如下：

\begin{lstlisting}[frame=shadowbox]
void GPIO_Config(void)
{
/* Enable each GPIO Clock (to be able to program the configuration registers) */
  __HAL_RCC_GPIOA_CLK_ENABLE();
  
  /* Configure IOs in output push-pull mode to drive external LED */
  GPIO_InitStruct.Mode  = GPIO_MODE_OUTPUT_PP;	// 推挽输出
  GPIO_InitStruct.Pull  = GPIO_PULLUP;					// 上拉
  GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;			// 高速

  GPIO_InitStruct.Pin = GPIO_PIN_8;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);				// 引脚为PA8
}

\end{lstlisting}
然后进入死循环状态，通过调用HAL\_GPIO\_TogglePin()函数对GPIOA的8号引脚进行翻转，即实现LED灯的闪烁效果。具体的实现如下：

\begin{lstlisting}[frame=shadowbox]
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
}
\end{lstlisting}
利用异或操作实现对GPIO引脚状态的翻转。

每次翻转后调用HAL\_Delay()函数进行延时，延时时间为delay，以控制LED灯的闪烁频率。具体实现如下：

\begin{lstlisting}[frame=shadowbox]
__weak void HAL_Delay(__IO uint32_t Delay)
{
  uint32_t tickstart = 0;
  tickstart = HAL_GetTick();
  while((HAL_GetTick() - tickstart) < Delay)
  {
  }
}
\end{lstlisting}
HAL\_Delay()函数通过调用HAL\_GetTick()函数获取当前的系统滴答计数值，然后通过循环判断当前的系统滴答计数值与tickstart的差值是否小于Delay，若小于则继续循环，否则退出循环，从而实现延时效果。

\noindent
\textbf{进阶实验}：请自行搜索摩尔斯密码表，通过控制D1的亮灭间隔，实现自己姓氏拼音的电码实现。

摩尔斯电码（Morse code）也被称作摩斯密码，是一种时通时断的信号代码，通过不同的排列顺序来表达不同的英文字母、数字和标点符号。这里我们通过控制D1的亮灭间隔，实现自己姓氏拼音的电码。

具体的算法思路如下：

\begin{enumerate}
    \item 姓氏的拼音用英文打出，姓氏拼音有多个英文字母组成，英文字母之间用空格隔开，每一个姓之间用逗号隔开；
    \item 定义短信号和长信号的时间分别为200ms和600ms，空格时长1000ms，逗号时长2000ms，正常信号之间的间隔为200ms；
\end{enumerate}

第一步中，我们小组有三位成员，分别姓：
% // wjy-WU=".-- ..-"
% // gx-GUO="--. ..- ---"
% // zzy-ZOU="--.. --- ..-"

\begin{itemize}
    \item WU=".-- ..-"
    \item GUO="--. ..- ---"
    \item ZOU="--.. --- ..-"
\end{itemize}

因此我们定义字符数组：
\begin{lstlisting}[frame=shadowbox]
char lname[]=".-- ..-,--. ..- ---,--.. --- ..-";
\end{lstlisting}

然后定义短信号和长信号的时间分别为200ms和600ms，空格时长1000ms，逗号时长2000ms，正常信号之间的间隔为200ms。

\begin{lstlisting}[frame=shadowbox]
uint16_t delay = 100;
uint16_t short_delay=200;
uint16_t long_delay=600;
uint16_t blank_delay=1000;
uint16_t gap_delay=2000;
\end{lstlisting}

根据电码序列的不同字母('.'/'-'/' '/',')分别使用短延迟、长延迟、空格延迟、逗号延迟的时长进行延迟，从而控制灯亮灭的间隔。

在死循环中，对整个字符数组进行遍历，根据字符的不同，进行不同的延迟操作，从而实现对LED灯的控制。

\begin{lstlisting}[frame=shadowbox]
    while(1){
        //turn on the LED light
        HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_8);
        if(lname[i%31]=='.'){
          HAL_Delay(short_delay);
        }else if(lname[i%31]=='-'){
          HAL_Delay(long_delay);
        }
        //turan off the LED light
        HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_8);
        //control delay of off state
        if(lname[(i+1)%31]==' '){
          HAL_Delay(blank_delay);
          i+=2;
        }
        else if(lname[(i+1)%31]==','){
          HAL_Delay(gap_delay);
          i+=2;
        }else{
          HAL_Delay(delay);
          i++;
        }
    }
\end{lstlisting}

\subsection{实验步骤}
\subsubsection{准备实验环境}
使用ULINK2 USB-JTAG仿真器连接ARM Cortex-M7实验板与PC，实验板一侧接P1接口。使用串口线，连接实验板上的串口J3和PC机的串口。接口P1和J3的位置如图所示。

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{imgs/2.png}
    \caption{接口P1和J3在实验板中的位置图}
\end{figure}

\subsubsection{串口接收设置}
在PC机上运行windows自带的超级终端串口通信程序（波特率115200 、1 位停止位、无校验位、无硬件流控制）；或者使用其它串口通信程序。 

\subsubsection{打开实验例程}
拷贝实验平台附带程序“02\_GPIO”，使用$\mu$Vision IDE for ARM通过 ULINK2 USB-JTAG仿真器连接实验板，打开工程文件，编译链接工程，点击MDK的Project菜单，选择Rebuild all target files进行编译，编译成功后，点击Debug菜单，选择Start/Stop Debug Session项或点击工具栏中的 图标，下载工程生成的.axf 文件到目标板的 RAM中调试运行。

\subsubsection{观察实验结果}
结合实验内容和相关资料，使用一些调试命令，观察程序运行。注意观察发光二极管的亮灭情况，观察到的现象与前面实验内容中的相符，则说明实验程序通过配置GPIO引脚的输出状态实现了对发光二极管的控制。修改代码，实现自己姓氏的摩尔斯电码。

\subsection{实验结果}

\subsection{实验结论}
本实验中，我们通过HAL\_GPIO\_TogglePin()可以切换LED灯状态，利用异或（XOR）操作取反GPIOx对应位的值，达到反转指定引脚状态的效果；同时，我们可以通过控制HAL\_GPIO\_TogglePin()的间隔来控制亮灯和灭灯的时间，对不同的字符设置不同的间隔时间来实现自己姓氏拼音的电码。实验源代码见附录。

\subsection{实验小结}
通过本实验，我更加熟练地掌握了vscode+Keil MDK开发环境的使用以及在线调试方法，对STM32F746NG芯片GPIO端口寄存器的配置有了更加直观的认识，并对C语言嵌入式编程有了初步的认识，收获很大。

\newpage

% 一、实验目的
% 指出此次实验应该达到的学习目标。
% 二、实验内容
% 指出此次实验应完成的任务。
% 三、实验方法
% 包括实验方法、原理、技术、方案等。
% 四、实验步骤
% 指出完成该实验的操作步骤。
% 五、实验结果
% 记录实验输出数据和结果。
% 六、实验结论
% 对实验数据和结果进行分析描述，给出实验取得的成果和结论。
% 注：有程序的要求附上程序源代码，有图表的要有截图并有相应的文字说明和分析
% 七、实验小结
% 给出本次实验的体会，如学会了什么，遇到哪些问题，如何解决这些问题，存在哪些有待改进的地方。

\section{实验2《中断实验》}

实验学时：2

每组人数：3

实验类别：2\ （1：基础性\ 2：综合性\ 3：设计性\ 4：研究性）

实验要求：1\ （1：必修\ 2：选修\ 3：其它）

实验类别：3\ （1：基础\ 2：专业基础\ 3：专业\ 4：其它）

\subsection{实验目的}
\begin{itemize}
  \item 掌握外部中断的处理流程；
  \item 掌握Cortex-M7处理器的中断方式和中断处理过程；
  \item 通过实验学习Cortex-M7处理器的中断响应流程；
  \item 通过实验掌握Cortex-M7处理器中断处理的软件编程方法；
  \item 通过实验掌握Cortex-M7处理器中断响应过程中相关寄存器的使用方法。
\end{itemize}

\subsection{实验内容}
编写程序，对指定GPIO端口进行初始化，完成外部中断相关寄存器的配置，使用ARM Cortex-M7实验平台的按键S3产生外部中断，在中断响应过程中对LED进行控制，并采用不同的中断设置方法实现多种中断触发方式。实验过程中观察上升沿触发选择寄存器（EXTI\_RTSR）和下降沿触发选择寄存器（EXTI\_FTSR）的值对中断触发条件的影响，学习Cortex-M7外部中断线的设置方法和初始化，以及外部中断的触发方式和响应过程。

\subsection{实验方法}
\subsubsection{实验原理}
\begin{enumerate}
  \item STM32F746NG的外部中断和事件控制器（EXTI）
  
  STM32F746NG具有多达24个用于产生中断/事件请求的边沿检测器（输入线）。每根输入线都可以单独进行配置，以选择类型（中断或事件）和响应的触发事件（上升沿触发、下降沿触发或边沿触发），每根输入线还可以单独屏蔽。挂起寄存器用于保持中断请求。
  EXTI控制器的主要特性如下：
  \begin{itemize}
    \item 每个中断/事件线上都具有独立的触发和屏蔽；
    \item 每个中断线具有专用的状态位；
    \item 支持多大24个软件事件/中断请求；
    \item 检测脉冲宽度低于APB2时钟宽度的外部信号。
  \end{itemize}
  要产生中断，必须先配置好并使能中断线。根据需要的边沿检测设置2个触发寄存器，同时在中断屏蔽寄存器的相应位写“1”使能中断请求。当外部中断线上出现选定信号沿时，便会产生中断请求，对应的挂起位也会置1。在挂起寄存器的对应位写“1”，将清除该中断请求。
  要产生事件，必须先配置好并使能事件线。根据需要的边沿检测设置2个触发寄存器，同时在事件屏蔽寄存器的相应位写“1”使能事件请求。当事件线上出现选定信号沿时，便会产生事件脉冲，对应的挂起位会置1。
  通过在软件中对中断/事件寄存器写“1”，也可以产生中断/事件请求。
  要将一根输入线配置为中断源，需执行以下步骤：
  \begin{enumerate}
    \item 配置相应的屏蔽位（EXTI\_IMR）；
    \item 配置中断线的触发选择位（EXTI\_RTSR和EXTI\_FTSR）；
    \item 配置对应到外部中断控制器（EXTI）的NVIC中断通道的使能和屏蔽位，使得24个中断线中的请求可以被正确的响应。
  \end{enumerate}
  要将一根输入线配置为事件源，需执行以下步骤：
  \begin{enumerate}
    \item 配置相应的屏蔽位（EXTI\_EMR）；
    \item 配置事件线的触发选择位（EXTI\_RTSR和EXTI\_FTSR）；
  \end{enumerate}
  \item 外部中断/事件线映射及控制器框图
  
  如图所示，多达168个GPIO通过图中方式连接到16个外部中断/事件线。
  \begin{figure}[htbp]
    \centering
    \includegraphics[width=0.3\textwidth]{imgs/3.png}
    \caption{外部中断/事件GPIO映射}
  \end{figure}
  另外8根EXTI线连接方式如下：
  \begin{itemize}
    \item EXTI16连接到PVD输出；
    \item EXTI17连接到RTC闹钟事件；
    \item EXTI18连接到USB OTG FS唤醒事件；
    \item EXTI19连接到以太网唤醒事件；
    \item EXTI20连接到USB OTG HS唤醒事件
    \item EXTI21连接到RTC侵入和时间戳事件
    \item EXTI22连接到RTC唤醒事件；
    \item EXTI23连接到LPTIM1异步事件。
  \end{itemize}
  EXTI控制器框图如图所示
  \begin{figure}[htbp]
    \centering
    \includegraphics[width=0.3\textwidth]{imgs/4.png}
    \caption{EXTI控制器框图}
  \end{figure}

  \item EXTI寄存器
  
  \begin{enumerate}
    \item 中断屏蔽寄存器（EXTI\_IMR）
    
    偏移地址：0x00

    复位值：0x0000 0000

    中断屏蔽寄存器如图所示
    \begin{figure}[htbp]
      \centering
      \includegraphics[width=0.8\textwidth]{imgs/5.png}
      \caption{中断屏蔽寄存器}
    \end{figure}

    位31:24保留，必须保持复位值。

    MRx：x线上的中断屏蔽

    0：屏蔽来自x线的中断请求

    1：开放来自x线的中断请求

    \item 事件屏蔽寄存器（EXTI\_EMR）
    
    偏移地址：0x04

    复位值：0x0000 0000

    事件屏蔽寄存器如图所示。

    \begin{figure}[htbp]
      \centering
      \includegraphics[width=0.8\textwidth]{imgs/6.png}
      \caption{事件屏蔽寄存器}
    \end{figure}

    位31:24保留，必须保持复位值。

    MRx：x线上的事件屏蔽

    0：屏蔽来自x线的事件请求

    1：开放来自x线的事件请求

    \item 上升沿触发选择寄存器（EXTI\_RTSR）
    
    偏移地址：0x08

    复位值：0x0000 0000

    上升沿触发选择寄存器如图所示。

    \begin{figure}[htbp]
      \centering
      \includegraphics[width=0.8\textwidth]{imgs/7.png}
      \caption{上升沿触发选择寄存器}
    \end{figure}

    位31:24保留，必须保持复位值。

    TRx：x线的上升沿触发事件配置位

    0：禁止输入线上升沿触发（事件和中断）

    1：开放输入线上升沿触发（事件和中断）

    注：外部唤醒线配置为边沿触发时，在这些线上不能出现毛刺信号。
    
    如果在向EXTI\_RTSR寄存器写入值的同时外部中断线上产生上升沿，挂起位将被置位。
    
    在同一中断线上，可以同时设置上升沿和下降沿触发，即任一边沿都可触发中断。

    \item 下降沿触发选择寄存器（EXTI\_FTSR）
    
    偏移地址：0x0C

    复位值：0x0000 0000

    下降沿触发选择寄存器如图所示。

    \begin{figure}[htbp]
      \centering
      \includegraphics[width=0.8\textwidth]{imgs/8.png}
      \caption{下降沿触发选择寄存器}
    \end{figure}

    位31:24保留，必须保持复位值。

    TRx：x线的下降沿触发事件配置位

    0：禁止输入线下降沿触发（事件和中断）

    1：开放输入线下降沿触发（事件和中断）

    注：外部唤醒线配置为边沿触发时，在这些线上不能出现毛刺信号。

    如果在向EXTI\_FTSR寄存器写入值的同时外部中断线上产生下降沿，挂起位将被置位。

    在同一中断线上，可以同时设置上升沿和下降沿触发，即任一边沿都可触发中断。
    
    \item 软件中断事件寄存器（EXTI\_SWIER）
    
    偏移地址：0x10

    复位值：0x0000 0000

    软件中断事件寄存器如图所示。

    \begin{figure}[htbp]
      \centering
      \includegraphics[width=0.8\textwidth]{imgs/9.png}
      \caption{软件中断事件寄存器}
    \end{figure}

    位31:24保留，必须保持复位值。

    SWIERx：x线的软件中断

    当SWIERx位设置为“0”时，将“1”写入该位会将EXTI\_PR寄存器中相应挂起位置1。如果在EXTI\_IMR寄存器中允许在x线上产生该中断，则产生中断请求。通过清除EXTI\_PR的对应位（写入“1”），可以清除该位为“0”。

    \item 挂起寄存器（EXTI\_PR）
    
    偏移地址：0x14

    复位值：未定义

    挂起寄存器如图所示。

    \begin{figure}[htbp]
      \centering
      \includegraphics[width=0.8\textwidth]{imgs/10.png}
      \caption{挂起寄存器}
    \end{figure}

    位31:24保留，必须保持复位值。

    PRx：x线的挂起

    0：未发生触发请求

    1：发生了选择的触发请求

    注：当在外部中断线上发生了选择的边沿事件，该位被置1，将此位编程为“1”可清除此位。
  \end{enumerate}

  \item EXTI寄存器边界地址
  
  EXTI寄存器边界地为0x4001 3C00 – 0x4001 3FFF。

  \item 实验电路
  
  如图所示

  \begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{imgs/11.png}
    \caption{实验电路}
  \end{figure}

  如图中所示，STM32F746芯片的PC13外接上拉电路，串联开关S3的Center（对应五向导航键S3的确定功能）后接地。由于I/O口外接上拉电路，所以在对I/O口进行初始化时可设置为浮空输入。开关S3断开时，PC13输入高电平；反之，PC13输入低电平。所以，当按下开关S3时，PC13输入由高变低，产生一个下降沿；当释放开关S3时，PC13输入由低变高，产生一个上升沿。根据外部中断触发条件设置，当满足所需的边沿条件时，触发中断，MCU响应中断点亮/熄灭发光二极管D1。
\end{enumerate}

\subsubsection{实验方案及调试过程}
\noindent
\textbf{基础实验}：本实验的实验例程（STM32F746\_Experiment\_v1.1/03\_EXTI）

实验例程如下：

\begin{lstlisting}[frame=shadowbox]
/**
  主程序：系统上电初始化后对LED1进行初始化，配置PC13作为外部中断源并开启中断，产生中断后点亮/熄灭LED。
**/
#include "main.h"
#include "system_init.h"

void System_Init(void);
void EXTI15_10_IRQHandler_Config(void);

/* main */
int main(void)
{
  System_Init();
  
  /* Initialize LED1 mounted on board */
  BSP_LED_Init(LED1);
  
  /* Configure EXTI15_10 (connected to PC.13 pin) in interrupt mode */
  EXTI15_10_IRQHandler_Config();
  
  while (1)
  {
  }
}

/* EXTI line detection callbacks, GPIO_Pin: Specifies the pins connected EXTI line */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)			//此处定义了HAL_GPIO_EXTI_Callback函数，原使用__weak  定义的函数被忽略�
{
  if (GPIO_Pin == GPIO_PIN_13)
  {
    /* Toggle LED1 */
    BSP_LED_Toggle(LED1);
    
    printf("\n\rLED1 switched\n\r");
  }
}
\end{lstlisting}
调试过程分析如下：

首先调用System\_Init()函数进行系统初始化，内部函数内容与实验一相同，不再赘述。

然后调用BSP\_LED\_Init()函数对LED1进行初始化，函数初始化板载LED1，使能LED1使其工作调用

\begin{lstlisting}[frame=shadowbox]
void BSP_LED_Init(Led_TypeDef Led)
{
  GPIO_InitTypeDef  gpio_init_structure;
  GPIO_TypeDef*     gpio_led;
	//Actualy only one LED
	switch(Led)
	{
		case LED1:
			/* Enable the GPIO_LED clock */
      LED1_GPIO_CLK_ENABLE();
			gpio_led = LED1_GPIO_PORT;
			break;
		case LED2:
			/* Enable the GPIO_LED clock */
      LED2_GPIO_CLK_ENABLE();
			gpio_led = LED2_GPIO_PORT;
			break;
		case LED3:
			/* Enable the GPIO_LED clock */
      LED3_GPIO_CLK_ENABLE();
			gpio_led = LED3_GPIO_PORT;
			break;
		case LED4:
			/* Enable the GPIO_LED clock */
      LED4_GPIO_CLK_ENABLE();
			gpio_led = LED4_GPIO_PORT;
			break;
		default:
			break;
	}
	/* Configure the GPIO_LED pin */
	gpio_init_structure.Pin = GPIO_PIN[Led];
	gpio_init_structure.Mode = GPIO_MODE_OUTPUT_PP;
	gpio_init_structure.Pull = GPIO_PULLUP;
	gpio_init_structure.Speed = GPIO_SPEED_HIGH;

	HAL_GPIO_Init(gpio_led, &gpio_init_structure);
	
	/* By default, turn off LED */
	HAL_GPIO_WritePin(gpio_led, GPIO_PIN[Led], GPIO_PIN_SET);
}
\end{lstlisting}
接着通过EXTI15\_10\_IRQHandler\_Config()函数配置PC13作为外部中断源并开启中断。

\begin{lstlisting}[frame=shadowbox]
void EXTI15_10_IRQHandler_Config(void)
{
  GPIO_InitTypeDef   GPIO_InitStructure;

  /* Enable GPIOC clock */
  __HAL_RCC_GPIOC_CLK_ENABLE();
	
  /* Configure PC.13 pin as input floating */
  GPIO_InitStructure.Mode = GPIO_MODE_IT_FALLING;				// 中断触发方式：下降沿触发
  GPIO_InitStructure.Pull = GPIO_NOPULL;								// GPIO内部无上拉或下拉
  GPIO_InitStructure.Pin = GPIO_PIN_13;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);						// 初始化PC13

  /* Enable and set EXTI lines 15 to 10 Interrupt to the lowest priority */
  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 2, 0);						// 设置中断优先级
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);										// 开中断
}
\end{lstlisting}
然后进入死循环，定义了下面的函数HAL\_GPIO\_EXTI\_Callback()，当发生中断时，自动调用该函数。该函数能够翻转LED1灯状态，从而完成改变LED灯亮灭状态的功能

\begin{lstlisting}[frame=shadowbox]
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)			//此处定义了HAL_GPIO_EXTI_Callback函数，原使用__weak  定义的函数被忽略
{
  if (GPIO_Pin == GPIO_PIN_13)
  {
    /* Toggle LED1 */
    BSP_LED_Toggle(LED1);
    
    printf("\n\rLED1 switched\n\r");
  }
}
\end{lstlisting}

\noindent
\textbf{进阶实验}：按下按键触发中断LED灯高频闪烁，提起按键触发中断LED灯熄灭

具体的算法思路如下：

在config.c文件中配置中断触发方式为上升沿和下降沿（GPIO\_MODE\_IT\_RISING\_
FALLING），并设置一个全局变量down用来记录按键状态。HAL\_GPIO\_ReadPin () 可以读取按键状态，按下按键时为低电压，则为0，抬起按键时为高电压，即为1，实现的函数如下：

\begin{lstlisting}[frame=shadowbox]
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin){
  if(GPIO_Pin==GPIO_PIN_13){
    down=HAL_GPIO_ReadPin(GPIOC,GPIO_Pin);
  }
}
\end{lstlisting}
由此我们可以判断按键是否按键，并通过读取全局变量 down 值控制 LED 灯状态，实现按下按键时LED灯闪烁，松开按键时LED灯关闭。  

\begin{lstlisting}[frame=shadowbox]
int main(void)
{
  System_Init();
  
  /* Initialize LED1 mounted on board */
  BSP_LED_Init(LED1);
  
  /* Configure EXTI15_10 (connected to PC.13 pin) in interrupt mode */
  EXTI15_10_IRQHandler_Config();
  
  while (1)
  {
    if(down==0){
      BSP_LED_Toggle(LED1);
      HAL_Delay(short_delay);
      BSP_LED_Toggle(LED1);
      HAL_Delay(short_delay);
    }
  }
}
\end{lstlisting}

\subsection{实验步骤}

\subsubsection{准备实验环境}
使用ULINK2 USB-JTAG仿真器连接ARM Cortex-M7实验板与PC，实验板一侧接右下方的P1接口。使用串口线，连接实验板右侧的串口J3和PC机的串口。

\subsubsection{串口接收设置}
在PC机上运行windows自带的超级终端串口通信程序（波特率115200 、1 位停止位、无校验位、无硬件流控制）；或者使用其它串口通信程序。

\subsubsection{打开实验例程}
拷贝实验平台附带程序“03\_EXTI”，使用$\mu$Vision IDE for ARM通过 ULINK2 USB-JTAG仿真器连接实验板，打开工程文件，编译链接工程，根据本实验指导书中2.3.2小节中“编译配置”部分对工程进行配置（工程默认已经配置正确），点击MDK的Project菜单，选择Rebuild all target files进行编译，编译成功后，点击Debug菜单，选择Start/Stop Debug Session项或点击工具栏中的 图标，下载工程生成的.axf 文件到目标板的 RAM中调试运行。

\subsubsection{观察实验结果}
结合实验内容和相关资料，使用一些调试命令，观察程序运行。注意观察按键S3按下和释放时发光二极管D1的亮灭情况，观察到的现象与前面实验内容中的相符，则说明实验程序通过将GPIO配置为EXTI的中断源，通过按键开关触发外部中断，MCU响应中断并点亮/熄灭发光二极管。修改部分代码，实现按下高频闪烁，松开熄灭的功能。

\subsection{实验结果}

\subsection{实验结论}
本实验中，我们首先观察到程序通过将GPIO配置为EXTI的中断源，通过按键开关触发外部中断，MCU响应中断并点亮/熄灭发光二极管。我们配置中断触发方式为上升沿和下降沿，并通过HAL\_GPIO\_ReadPin()读取按键状态，并根据按键状态控制 LED 灯状态，从而完成了实验要求的功能。实验源代码见附录。

\subsection{实验小结}
通过本实验，我更加熟练地掌握了Cortex-M7处理器的中断方式和中断处理过程，并熟悉了Cortex-M7处理器中断处理的软件编程方法和其中断响应过程中相关寄存器的使用方法，同时对嵌入式系统中电路与程序的关系有了进一步的认识，收获很大。

\newpage

\section{实验3《Uart+定时器实验》}

实验学时：2

每组人数：3

实验类别：2\ （1：基础性\ 2：综合性\ 3：设计性\ 4：研究性）

实验要求：1\ （1：必修\ 2：选修\ 3：其它）

实验类别：3\ （1：基础\ 2：专业基础\ 3：专业\ 4：其它）

\subsection{实验目的}
\begin{enumerate}
  \item 掌握UART串口的工作原理；
  \item 掌握Cortex-M7的UART串口配置方法；
  \item 通过实验掌握printf()函数重定向的方法；
  \item 通过实验掌握Cortex-M7串口通信及调试方法；
  \item 掌握Cortex-M7定时器的工作原理；
  \item 掌握Cortex-M7定时器的配置及初始化方法；
  \item 通过实验掌握定时器中断的设置和使用方法；
  \item 通过实验掌握定时器中断的响应流程。
\end{enumerate}

\subsection{实验内容}
\begin{enumerate}
  \item 引导输入功能：编译运行，超级终端可以通过Uart接收到ARM板子回传的信息，要求用户输入一串数字（浮点数或整数）
  \item 实时回显功能：ARM接收到用户的每个字符，需要将本字符在回传到超级终端，使得用户可以看到自己输入的字符，按下回车键，ARM程序开始处理用户输入字符串，如果不是数字字符（小数或整数）则回显提示错误；如果是数字字符开始执行后面功能；
  \item 数字识别功能：将用户输入的字符串，识别成具体的数字，这个数字表示LED灯闪烁的时间间隔。
  \item 灯光闪烁频率（单位Hz）控制：以上面收到的数据去设定定时器，控制LED灯的闪烁间隔。示例：用户输入1，1Hz表示那么LED灯应该1S完成一次亮灭循环，也就是亮0.5s灭0.5s，如此循环往复
\end{enumerate}

\subsection{实验方法}
\subsubsection{实验原理}
\begin{enumerate}
  \item UART通信协议
  
  UART（Universal Asynchronous Receiver and Transmitter）通用异步收发器是异步串行通信接口的总称，支持RS-232、RS-422、RS-485等接口标准规范和总线标准规范。

  UART作为异步串口通信协议的一种，工作原理是将传输数据的每个字符一位接一位的传输其中每一位(Bit)的意义如下：
  \begin{itemize}
    \item 起始位：先发出一个逻辑“0”的信号，表示传输字符的开始。
    \item 数据位：紧接着起始位之后。数据位的个数可以是4、5、6、7、8等，构成一个字符。从最低位开始传送，靠时钟定位
    \item 奇偶校验位：数据位加上这一位后，使得“1”的位数应为偶数(偶校验)或奇数(奇校验)，以此来校验数据传送的正确性。
    \item 停止位：它是一个字符数据的结束标志。可以是1位、1.5位、2位的高电平。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢。
    \item 空闲位：处于逻辑“1”状态，表示当前线路上没有数据传送
  \end{itemize}
  UART协议传输时序如图所示
  \begin{figure}[htbp]
    \centering
    \includegraphics[width=0.8\textwidth]{imgs/12.png}
    \caption{UART协议传输时序}
  \end{figure}

  发送数据过程：空闲状态，线路处于高电位；当收到发送数据指令后，拉低线路一个数据位的时间T，接着数据按低位到高位依次发送，数据发送完毕后，接着发送奇偶校验位和停止位（停止位为高电位），一帧数据发送结束。

  发送数据过程：空闲状态，线路处于高电位；当收到发送数据指令后，拉低线路一个数据位的时间T，接着数据按低位到高位依次发送，数据发送完毕后，接着发送奇偶校验位和停止位（停止位为高电位），一帧数据发送结束。

  波特率是衡量数据传输速率的指标，表示每秒传送数据的字符数，单位为Baud。UART的接收和发送是按照相同的波特率进行收发的。波特率发生器产生的时钟频率不是波特率时钟频率，而是波特率时钟频率的16倍，目的是为在接收时进行精确地采样，以提取出异步的串行数据。根据给定的晶振时钟和要求的波特率，可以算出波特率分频计数值。

  \item printf()函数重定向
  
  标准库函数的默认输出设备是显示器，因此必须对重新定义printf()函数中与串口输出相关的函数，才能通过调用printf()函数向串口发送数据。

  使用以下代码可以完成printf()函数的重定义：
  
  \begin{lstlisting}[frame=shadowbox]
    #ifdef __GNUC__
/* With GCC/RAISONANCE, small printf (option LD Linker->Libraries->Small printf
   set to 'Yes') calls __io_putchar() */
#define PUTCHAR_PROTOTYPE int __io_putchar(int ch)
#else
#define PUTCHAR_PROTOTYPE int fputc(int ch, FILE *f)
#endif /* __GNUC__ */

/* Retargets the C library printf function to the UART */
PUTCHAR_PROTOTYPE
{
  /* Place your implementation of fputc here */
  /* e.g. write a character to the COM1 and Loop until the end of transmission */
  HAL_UART_Transmit(&Uart_Handle, (uint8_t *)&ch, 1, 0xFFFF);

  return ch;
}

  \end{lstlisting}

  由于GNU编译器中printf()调用的是putchar()函数执行底层输出任务，所以前半段代码使用宏定义可以兼容不同编译器。

  后半段即重定义过程，使用HAL\_UART\_Transmit()函数完成fputc()或putchar()函数的底层输出任务。HAL\_UART\_Transmit()函数的具体定义可以在实验例程“03\_U
  ART”中查看

  \item 定时器
  
  Cortex-M7具有2个高级控制定时器、10个通用定时器、2个基本定时器和2个看门狗定时器。特性对比如表所示

  \begin{table}
    \centering
    \begin{tblr}{
      cell{3}{1} = {r=6}{},
      vlines,
      hline{1-3,9-10} = {-}{},
      hline{4-8} = {2-5}{},
    }
    定时器类型   & 定时器         & 位数 & 计数模式      & 分频系数                      \\
    高级控制定时器 & TIM1,TIM8   & 16 & 递增，递减，增/减 & 1\textasciitilde{}65536之间 \\
    通用定时器   & TIM2,TIM5   & 32 & 递增，递减，增/减 & 1\textasciitilde{}65536之间 \\
            & TIM3,TIM4   & 16 & 递增，递减，增/减 & 1\textasciitilde{}65536之间 \\
            & TIM9        & 16 & 递增        & 1\textasciitilde{}65536之间 \\
            & TIM11,TIM10 & 16 & 递增        & 1\textasciitilde{}65536之间 \\
            & TIM12       & 16 & 递增        & 1\textasciitilde{}65536之间 \\
            & TIM13,TIM14 & 16 & 递增        & 1\textasciitilde{}65536之间 \\
    基本定时器   & TIM6,TIM7   & 16 & 递增        & 1\textasciitilde{}65536之间 
    \end{tblr}
    \end{table}

    下面以实验例程中所用的通用定时器为例，介绍Cortex-M7中定时器的主要功能和用法

    \item 通用定时器
    
    通用定时器包含一个16位或32位自动重载计数器，该计数器由可编程预分频器驱动。它们可用于多种用途，包括测量输入信号的脉冲宽度（输入捕获）或生成输出波形（输出比较和PWM）。

    使用定时器预分频器和RCC时钟控制器预分频器，可将脉冲宽度和波形周期从几微秒调制到几毫秒

    这些定时器彼此完全独立，不共享任何资源。

    通用 TIMx 定时器具有以下特性：
    \begin{itemize}
      \item 16 位（TIM3 和 TIM4）或 32 位（TIM2 和 TIM5）递增、递减和递增/递减自动重载计数器。
      \item 16 位可编程预分频器，用于对计数器时钟频率进行分频（可在运行时修改），分频系数介于 1 到 65535 之间。
      \item 多达 4 个独立通道，可用于
      \begin{itemize}
        \item 输入捕获
        \item 输出比较
        \item PWM 生成（边沿和中心对齐模式）
        \item 单脉冲模式输出
      \end{itemize}
      \item 使用外部信号控制定时器且可实现多个定时器互连的同步电路。
      \item 发生如下事件时生成中断/DMA 请求：
      \begin{itemize}
        \item 更新：计数器上溢/下溢、计数器初始化（通过软件或内部/外部触发）
        \item 触发事件（计数器启动、停止、初始化或通过内部/外部触发计数）
        \item 输入捕获
        \item 输出比较
      \end{itemize}
      \item 支持定位用增量（正交）编码器和霍尔传感器电路
      \item 触发输入作为外部时钟或者逐周期电流管理
    \end{itemize}

    本实验例程中使用定时器的时基单元功能，即定时功能

    可编程定时器的主要模块由一个 16 位/32 位计数器及其相关的自动重装寄存器组成。计数器可递增计数、递减计数或同时递增和递减计数。计数器的时钟可通过预分频器进行分频。计数器、自动重载寄存器和预分频器寄存器可通过软件进行读写。即使在计数器运行时也可执行读写操作。

    时基单元包括：

    \begin{itemize}
      \item 计数器寄存器 (TIMx\_CNT)
      \item 预分频器寄存器 (TIMx\_PSC)
      \item 自动重载寄存器 (TIMx\_ARR)
    \end{itemize}

    本实验中采用递增计数模式，计数器从0计数到自动重载值（TIMx\_ARR寄存器的内容），然后重新从0开始计数并生成计数器上溢事件，即定时器中断。

    若采用递减计数模式，计数器从自动重载值（TIMx\_ARR寄存器的内容）开始递减计数到0，然后重新从自动重载值开始计数并生成计数器下溢事件。

    计数器由预分频器输出 CK\_CNT 提供时钟，仅当 TIMx\_CR1 寄存器中的计数器启动位(CEN)置1时，才会启动计数器

    预分频器说明：

    预分频器可对计数器时钟频率进行分频，分频系数介于 1 和 65536 之间。该预分频器基于16 位/32 位寄存器（TIMx\_PSC 寄存器）所控制的 16 位计数器。由于该控制寄存器具有缓冲功能，因此预分频器可实现实时更改。而新的预分频比将在下一更新事件发生时被采用。定时器频率计算方法及定时器中断原理定时器3频率计算方法如下：

    TIMER3时钟频率（TIM3CLK）为APB1总线时钟频率（PCLK1）的2倍，APB1总线时钟频率为系统时钟的1/4，

    即

    $TIM3CLK = 2 * PCLK1$

    $PCLK1 = SystemCoreClock / 4$

    所以$TIM3CLK  =  SystemCoreClock / 2$

    本实验例程中需要将TIMER3时钟频率配置为10KHz，由于采用递增计数模式，预分频计算方式如下：

    $Prescaler  =  ( TIM3CLK / TIM3 counter clock ) - 1$

    $Prescaler  =  ( ( SystemCoreClock / 2 ) / ( 10KHz ) - 1$

    所以在对定时器3初始化时，需要按照以上方法计算预分频数值
\end{enumerate}

\subsubsection{实验方案及调试过程}

本实验要求通过超级终端输入闪烁频率（单位Hz），LED灯按设定频率闪烁，可连续输入数字改变频率。

具体的算法思路如下：

从UART串口中接收数据，调用printf()函数将接收到的数据回传到超级终端，将接收到的字符判断是否合规，不合规的字符通过printf()函数回传错误信息，实现“引导输入”、“实时回显”功能，合规的字符转换为数字，并存储到栈中

\begin{lstlisting}[frame=shadowbox]
HAL_UART_Receive(&UartHandle,(uint8_t*)&uRxBuffer,1,TIMEOUT);
      printf("%c",uRxBuffer);
      if(uRxBuffer!='\r'&&uRxBuffer!='\n'){
        if((uRxBuffer>='0'&&uRxBuffer<='9')||uRxBuffer=='.'){
          stack[store]=uRxBuffer;
          store++;
        }else{
          printf("\n\r INPUT ERROR! \n\r");
          break;
        }
      }  
\end{lstlisting}
接收到的合法小数字符数组通过sscanf函数解析成浮点数，根据公式计算值计算ARR值

\begin{lstlisting}[frame=shadowbox]
  HAL_UART_Receive(&UartHandle,(uint8_t*)&uRxBuffer,1,TIMEOUT);
      printf("%c",uRxBuffer);
      if(uRxBuffer!='\r'&&uRxBuffer!='\n'){
        if((uRxBuffer>='0'&&uRxBuffer<='9')||uRxBuffer=='.'){
          stack[store]=uRxBuffer;
          store++;
        }else{
          printf("\n\r INPUT ERROR! \n\r");
          break;
        }
      }
\end{lstlisting}
使用定时器 Tim3 配置中断，控制灯光的闪烁频率，完成程序功能。

\begin{lstlisting}[frame=shadowbox]
  Timer_Config(ARRValue);

  HAL_TIM_Base_Start_IT(&TimHandle);
\end{lstlisting}

\subsection{实验步骤}
\subsubsection{准备实验环境}
使用ULINK2 USB-JTAG仿真器连接ARM Cortex-M7实验板与PC，实验板一侧接右下方的P1接口。使用串口线，连接实验板右侧的串口J3和PC机的串口。

\subsubsection{串口接收设置}
在PC机上运行windows自带的超级终端串口通信程序（波特率115200 、1位停止位、无校验位、无硬件流控制）；或者使用其它串口通信程序。

\subsubsection{打开实验例程}
拷贝实验平台附带程序“05\_TIMER”，使用$\mu$Vision IDE for ARM通过ULINK2 USB-JTAG仿真器连接实验板，打开工程文件，编译链接工程，对工程进行配置，点击MDK的Project菜单，选择Rebuild all target files进行编译，编译成功后，点击Debug菜单，选择Start/Stop Debug Session项或点击工具栏中的 图标，下载工程生成的.axf 文件到目标板的 RAM中调试运行。

\subsubsection{观察实验结果}
观察PC中超级终端显示信息，根据提示使用键盘输入数据，MCU接收到数据后对TIMER3的TIM3\_ARR寄存器进行相应配置并完成定时器中断的初始化。初始化结束后开启TIMER3开始计时，产生定时器中断后对LED执行跳变操作，即观察到LED以高或低频率闪烁。

\subsection{实验结果}

\subsection{实验结论}
本实验中，我们在while循环中通过Uart通信协议逐字符接收消息并回显在超级终端上，并使用sscanf()函数将数字字符转化为double型变量使得程序可以接收小数；通过设置定时器让LED灯持续闪烁，当下一次输入新值后会重新设置LED灯闪烁频率，达到程序目的。实验源代码见附录。

\subsection{实验小结}
通过本实验，我掌握了Cortex-M7的UART串口配置方法，串口通信及调试方法，并学习了定时器中断的设置和使用方法，熟悉了定时器中断的响应流程，同时进一步熟悉了C语言嵌入式编程，感受到嵌入式系统应用的魅力所在，收获很大。

\newpage

\section{实验4《$\mu$C/OS-III 实验——信号量》}

实验学时：2

每组人数：3

实验类别：2\ （1：基础性\ 2：综合性\ 3：设计性\ 4：研究性）

实验要求：1\ （1：必修\ 2：选修\ 3：其它）

实验类别：3\ （1：基础\ 2：专业基础\ 3：专业\ 4：其它）

\subsection{实验目的}
\begin{enumerate}
  \item 掌握$\mu$C/OS-III操作系统中信号量的创建方法；
  \item 通过实验掌握$\mu$C/OS-III系统中使用信号量进行任务间通信的方法。
\end{enumerate}

\subsection{实验内容}
用$\mu$C/OS-III系统的信号量机制实现按下按键LED灯闪烁，松开按键停止闪烁。在实验过程中学习$\mu$C/OS-III操作系统中信号量的创建和使用方法，在实验中注意观察LED的闪烁以及串口数据的变化情况，掌握使用信号量进行任务间通信的方法。

\subsection{实验方法}

\subsubsection{实验原理}

\begin{enumerate}
  \item 信号量
  
  信号量是在多任务环境下使用的一种设施，是可以用来保证两个或多个关键代码段不被并发调用。在进入一个关键代码段之前，线程必须获取一个信号量；一旦该关键代码段完成了，那么该线程必须释放信号量。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量。为了完成这个过程，需要创建一个信号量Semaphore，然后将获取Semaphore以及释放Semaphore的代码分别放置在每个关键代码段的首末端。

  抽象的来讲，信号量的特性如下：信号量是一个非负整数，所有使用它的线程/进程都会将该整数减一，当该整数值为零时，所有试图使用它的线程都将处于等待状态。在信号量上我们定义两种操作： Wait（等待） 和 Release（释放）。当一个线程调用Wait操作时，它要么得到资源然后将信号量减一，要么一直等下去（指放入阻塞队列），直到信号量大于等于一时。Release（释放）实际上是在信号量上执行加操作，该操作之所以叫做“释放”是因为释放了由信号量守护的资源。

  在$\mu$C/OS-III中，使用OSSemCreate函数可以创建一个信号量，其原型如下：

  \begin{lstlisting}[frame=shadowbox]
void  OSSemCreate (OS_SEM  *p_sem, 
CPU_CHAR  *p_name,
OS_SEM_CTR  cnt,
OS_ERR  *p_err) 

  \end{lstlisting}
  使用OSSemPend函数可以获取一个信号量，若获取到信号量，则任务继续执行，否则该挂起该任务，直到该任务获取到信号量或超时。OSSemPend函数的原型如下：

  \begin{lstlisting}[frame=shadowbox]
OS_SEM_CTR  OSSemPend (OS_SEM   *p_sem,
OS_TICK   timeout,
OS_OPT    opt,
CPU_TS   *p_ts,
OS_ERR   *p_err)
  \end{lstlisting}
  使用OSSemPost函数可以释放一个信号量，其原型如下：

  \begin{lstlisting}[frame=shadowbox]
OS_SEM_CTR  OSSemPost (OS_SEM  *p_sem,
OS_OPT   opt,
OS_ERR  *p_err)

  \end{lstlisting}

  \item 实验例程说明
  \begin{enumerate}
    \item 系统初始化（HAL库、内存管理模块和数学算法模块的初始化）；
    \item 创建启动任务AppTaskStart；
    \item 在启动任务中对BSP和CPU进行初始化；
    \item 在启动任务中创建通信过程中使用的信号量等对象；
    \item 在启动任务中创建两个应用任务Task\_A和Task\_B，启动任务进入死循环；
    \item Task\_A检测S3是否被按下并释放，当S3释放时向Task\_B发送信号量；
    \item Task\_B等待Task\_A发送来的信号量，当获取到信号量时点亮/熄灭LED1并向串口发送数据。
  \end{enumerate}
\end{enumerate}

\subsubsection{实验方案及调试过程}
本实验要求通过$\mu$C/OS-III操作系统中的信号量机制完成按下按键LED灯高频闪烁，提起按键LED灯熄灭的功能。

具体的算法思路如下：

首先创建等待键盘按键检测的任务和信号量机制相关的操作系统对象，定义任务名为Task A 和Task B

\begin{lstlisting}[frame=shadowbox]
  static  void  AppTaskCreate (void)
{
    OS_ERR  os_err;

/* ---------- 创建应用任务 --------- */
    OSTaskCreate(&Task_ATCB,
                 "Kernel Objects Task A",
                  Task_A,
                  0,
                  APP_CFG_TASK_OBJ_PRIO,
                 &Task_AStk[0],
                  Task_AStk[APP_CFG_TASK_OBJ_STK_SIZE / 10u],
                  APP_CFG_TASK_OBJ_STK_SIZE,
                  0u,
                  0u,
                  0,
                 (OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
                 &os_err);

    OSTaskCreate(&Task_BTCB,
                 "Kernel Objects Task B",
                  Task_B,
                  0,
                  APP_CFG_TASK_OBJ_PRIO,
                 &Task_BStk[0],
                  Task_BStk[APP_CFG_TASK_OBJ_STK_SIZE / 10u],
                  APP_CFG_TASK_OBJ_STK_SIZE,
                  0u,
                  0u,
                  0,
                 (OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
                 &os_err);
}

static  void  AppObjCreate (void)
{
    OS_ERR  os_err;

#if (OS_CFG_SEM_EN > 0u)
    OSSemCreate(&wait_key_sem,
                "Key Detection",
                 0u,
                &os_err);
    OSSemCreate(&wait_key_sem2,"Key Detection",0u,&os_err);
#endif
}
\end{lstlisting}
当检测到按键被按下时，任务 Task\_A 会发送信号量 wait\_key\_sem：

\begin{lstlisting}[frame=shadowbox]
void Task_A(void *p_arg)
{	   
	OS_ERR  err;
	unsigned char key_press = 0;

	while(DEF_TRUE)
	{
	// 	OSTimeDly(30, OS_OPT_TIME_DLY, &err);
    // if (BSP_PB_GetState(BUTTON_TAMPER) == RESET)
	// 		key_press = 1;
	// 	if (BSP_PB_GetState(BUTTON_TAMPER) == SET)
	// 	{
	// 		if(key_press == 1)
	// 		{
	// 			key_press = 0;
	// 			OSSemPost(&wait_key_sem, OS_OPT_POST_1, &err);
	// 		}
	// 	}	
        OSTimeDly(60, OS_OPT_TIME_DLY, &err);
				if (BSP_PB_GetState(BUTTON_TAMPER) == RESET){
            OSSemPost(&wait_key_sem, OS_OPT_POST_1, &err);
        }
	}
}
\end{lstlisting}
当任务 Task\_B 接收到信号量信息后，会通过 BSP\_LED\_Toggle(LED1) 函数控制 LED 灯的高速闪烁；且发送信号量任务的系统时钟节拍与接收信号量任务的系统时钟节拍保持一致，从而使得当按键抬起时 LED 灯不再闪烁。具体代码如下：

\begin{lstlisting}[frame=shadowbox]
void Task_B(void *p_arg)
{			  
	OS_ERR  err;
	CPU_TS  ts;

	while(DEF_TRUE)
	{
		OSTimeDly(30, OS_OPT_TIME_DLY, &err);
		OSSemPend(&wait_key_sem,
                  0,
                  OS_OPT_PEND_BLOCKING,
                  &ts,
                  &err);
		BSP_LED_Toggle(LED1);	//Toggle after key release
        OSTimeDly(30, OS_OPT_TIME_DLY, &err);
        BSP_LED_Toggle(LED1);
		APP_TRACE_DBG(("Get a Semaphore from Task A\n\r"));
	}
}
\end{lstlisting}

\subsection{实验步骤}
\subsubsection{准备实验环境}
使用ULINK2 USB-JTAG仿真器连接ARM Cortex-M7实验板与PC，实验板一侧接右下方的P1接口。使用串口线，连接实验板右侧的串口J3和PC机的串口。

\subsubsection{串口接收设置}
在PC机上运行windows自带的超级终端串口通信程序（波特率115200 、1 位停止位、无校验位、无硬件流控制）；或者使用其它串口通信程序。

\subsubsection{打开实验例程}
拷贝实验平台附带程序“14\_uCOS-III\_Semaphore”，使用$\mu$Vision IDE for ARM通过 ULINK2 USB-JTAG仿真器连接实验板，打开工程文件，编译链接工程，根据本实验指导书中2.3.2小节中“编译配置”部分对工程进行配置（工程默认已经配置正确），点击MDK的Project菜单，选择Rebuild all target files进行编译，编译成功后，点击Debug菜单，选择Start/Stop Debug Session项或点击工具栏中的 图标，下载工程生成的.axf 文件到目标板的 RAM中调试运行。

\subsubsection{观察实验结果}
我们观察到按下按键LED灯高频闪烁，提起按键LED灯熄灭，说明我们通过$\mu$C/OS-III操作系统中的信号量机制完成了实验需要的功能

\subsection{实验结果}

\subsection{实验结论}
本实验中，首先创建等待键盘按键检测的应用进程，通过$\mu$C/OS-III操作系统中的信号量机制，实现当接收到按键按下信号后通过 BSP\_LED\_Toggle(LED1)函数控制 LED 灯的高速闪烁，并保持发送信号量任务的系统时钟节拍与接收信号量任务的系统时钟节拍一致，从而当提起按键后LED灯停止闪烁。实验源代码见附录。

\subsection{实验小结}
通过本实验，我掌握了$\mu$C/OS-III系统中信号量的创建方法和使用信号量进行任务间通信的方法，对C语言嵌入式编程有了更多的认识，直观地了解到信号量机制在嵌入式系统中的广泛用途与应用，收获很大。

\newpage

\section{附录}
\subsection{实验1源代码}
\begin{lstlisting}[frame=shadowbox]
    /**
    主程序：系统上电初始化后对GPIO中的PA8进行配置，将其配置为输出端口并控制LED闪烁。
  **/
  #include "main.h"
  #include "system_init.h"
  
  /* Private variables */
  uint16_t delay = 100;
  
  uint16_t short_delay=200;
  uint16_t long_delay=600;
  uint16_t blank_delay=1000;
  uint16_t gap_delay=2000;
  
  void System_Init(void);
  void GPIO_Config(void);
  
  /* main */
  int main(void)
  {
    System_Init();
    
    GPIO_Config();
    
    printf("\n\rExample finished\n\r");
  
    // wjy-WU=".-- ..-"
    // gx-GUO="--. ..- ---"
    // zzy-ZOU="--.. --- ..-"
    char lname[]=".-- ..-,--. ..- ---,--.. --- ..-";
    int i=0;
  
    /* Toggle IOs in an infinite loop */
    // while (1)
    // {
    //   HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_8);
    //   /* Insert delay */
    //   HAL_Delay(delay);
    // }
  
    // 打印姓氏
    // 方法：
    // 形势的拼音用英文字母打出，每个字有多个英文字母组成，英文字母之间用空格隔开，每一个姓之间用逗号隔开
    // 设置长信号为600ms，短信号为200ms，空格为1000ms，姓之间间隔为2000ms，信号间隔100ms
    while(1){
      //turn on the LED light
      HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_8);
      if(lname[i%31]=='.'){
        HAL_Delay(short_delay);
      }else if(lname[i%31]=='-'){
        HAL_Delay(long_delay);
      }
      //turan off the LED light
      HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_8);
      //control delay of off state
      if(lname[(i+1)%31]==' '){
        HAL_Delay(blank_delay);
        i+=2;
      }
      else if(lname[(i+1)%31]==','){
        HAL_Delay(gap_delay);
        i+=2;
      }else{
        HAL_Delay(delay);
        i++;
      }
    }
  }  
\end{lstlisting}

\newpage

\subsection{实验2源代码}
\begin{lstlisting}[frame=shadowbox]
/**
  主程序：系统上电初始化后对LED1进行初始化，配置PC13作为外部中断源并开启中断，产生中断后点亮/熄灭LED。
**/
#include "main.h"
#include "system_init.h"

void System_Init(void);
void EXTI15_10_IRQHandler_Config(void);

uint16_t short_delay=100;
uint16_t down=1;

/* main */
int main(void)
{
  System_Init();
  
  /* Initialize LED1 mounted on board */
  BSP_LED_Init(LED1);
  
  /* Configure EXTI15_10 (connected to PC.13 pin) in interrupt mode */
  EXTI15_10_IRQHandler_Config();
  
  while (1)
  {
    if(down==0){
      BSP_LED_Toggle(LED1);
      HAL_Delay(short_delay);
      BSP_LED_Toggle(LED1);
      HAL_Delay(short_delay);
    }
  }
}

/* EXTI line detection callbacks, GPIO_Pin: Specifies the pins connected EXTI line */
// void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)			//此处定义了HAL_GPIO_EXTI_Callback函数，原使用__weak  定义的函数被忽略
// {
//   if (GPIO_Pin == GPIO_PIN_13)
//   {
//     /* Toggle LED1 */
//     BSP_LED_Toggle(LED1);
    
//     printf("\n\rLED1 switched\n\r");
//   }
// }

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin){
  if(GPIO_Pin==GPIO_PIN_13){
    down=HAL_GPIO_ReadPin(GPIOC,GPIO_Pin);
  }
}
\end{lstlisting}

\newpage

\subsection{实验3源代码}
\begin{lstlisting}[frame=shadowbox]
/**
  主程序：系统初始化后使用串口通信对Timer3的自动重载寄存器（ARR）初值进行选择，通过配置预分频，
	将Timer3的时钟频率设置为10KHz，在配置好定时器后开启定时器中断。Timer3的计数器寄存器从0开始以10KHz的频率递增，
	当其值大于ARR寄存器中的数值时，产生上溢，即定时器中断。
	注意：此例程中，每产生一次定时器中断，LED发生一次跳变，即模式1中LED闪烁频率为0.5Hz，模式2中LED闪烁频率为5Hz
**/
#include "main.h"
#include "system_init.h"

#define TIMEOUT   10000       // 10 seconds

/* Prescaler declaration */
uint8_t uRxBuffer = '1';			// 默认选择模式"1. 10000"
uint16_t ARRValue = 10000 - 1;// 默认ARR寄存器值为10000 - 1
extern UART_HandleTypeDef   UartHandle;
extern TIM_HandleTypeDef    TimHandle;

void System_Init(void);
void Timer_Config(uint16_t ARRValue);
    
/* main */
int main(void)
{
  System_Init();
  
  // printf("\n\r************************************\n\r");
  // printf("* Timer counter frequency is 10KHz *\n\r* Upcounting mode                  *\n\r* Initial value is 0               *");
  // printf("\n\r************************************\n\r");
  // printf("\n\rSelect the value of ARR register:\n\r1. 10000(default)    2. 1000\n\r");
  
  // /* Receive data from UART */
  // HAL_UART_Receive(&UartHandle, (uint8_t*)&uRxBuffer, 1, TIMEOUT);
  
  // if (uRxBuffer == '2')
  //   ARRValue = 1000 - 1;

  // Timer_Config(ARRValue);	//使用Tim3在这里面配置中断

  // /* Start the TIM Base generation in interrupt mode */
  // HAL_TIM_Base_Start_IT(&TimHandle);
  
  // printf("\n\rExample finished\n\r");
  
  while (1)
  {
    uint8_t stack[100];
    int store=0;

    double num=0;
    printf("\n\r**** UART-Timer ****\n\rPlease enter the frequency...\n\r");

    //receive data from uart
    while(1){
      HAL_UART_Receive(&UartHandle,(uint8_t*)&uRxBuffer,1,TIMEOUT);
      printf("%c",uRxBuffer);
      if(uRxBuffer!='\r'&&uRxBuffer!='\n'){
        if((uRxBuffer>='0'&&uRxBuffer<='9')||uRxBuffer=='.'){
          stack[store]=uRxBuffer;
          store++;
        }else{
          printf("\n\r INPUT ERROR! \n\r");
          break;
        }
      }

      if(uRxBuffer=='\r'||uRxBuffer=='\n'||store>10){
        sscanf((const char*)stack,"%lf",&num);
        ARRValue=5000/num-1;
        break;
      }
    }

    Timer_Config(ARRValue);

    HAL_TIM_Base_Start_IT(&TimHandle);
  }
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  BSP_LED_Toggle(LED1);
}

\end{lstlisting}

\newpage

\subsection{实验4源代码}
\begin{lstlisting}[frame=shadowbox]
/**
  主程序：上电后进行系统硬件初始化以及uC/OS-III初始化，完成初始化工作后创建启动
	任务：AppTaskStart，在该任务中完成板级支持包BSP和CPU模块的初始化，并创建
	两个应用任务Task_A和Task_B，其中Task_A检测按键S3是否被按下并释放，当S3释放时
	产生信号量，Task_B等待Task_A发送来的信号量，当获取到信号量时点亮/熄灭LED1并向
	串口发送数据。
**/
#include  <stdarg.h>
#include  <stdio.h>
#include  <math.h>
#include  <stm32f7xx_hal.h>
#include "stm32756g_eval.h"

#include  <cpu.h>
#include  <lib_math.h>
#include  <lib_mem.h>
#include  <os.h>
#include  <os_app_hooks.h>

#include  <app_cfg.h>
#include  <bsp.h>

#if (APP_CFG_SERIAL_EN == DEF_ENABLED)
#include  <app_serial.h>
#endif
/*
****************************************************
****************************************************
*
*                                            LOCAL DEFINES
****************************************************
****************************************************
*
*/

#define  APP_TASK_EQ_0_ITERATION_NBR              16u
#define  APP_TASK_EQ_1_ITERATION_NBR              18u


/*
****************************************************
****************************************************
*
*                                       LOCAL GLOBAL VARIABLES
****************************************************
****************************************************
*
*/
/* --------------- APPLICATION GLOBALS ---------------- */
static  OS_TCB       AppTaskStartTCB;
static  CPU_STK      AppTaskStartStk[APP_CFG_TASK_START_STK_SIZE];

/* --------------- SEMAPHORE TASK TEST --------------- */
static  OS_TCB       Task_ATCB;
static  CPU_STK      Task_AStk[APP_CFG_TASK_OBJ_STK_SIZE];

static  OS_TCB       Task_BTCB;
static  CPU_STK      Task_BStk[APP_CFG_TASK_OBJ_STK_SIZE];

#if (OS_CFG_SEM_EN > 0u)
static  OS_SEM       wait_key_sem;
static  OS_SEM       wait_key_sem2;
#endif

/*
****************************************************
****************************************************
*
*                                         FUNCTION PROTOTYPES
****************************************************
****************************************************
*
*/

static  void  AppTaskStart (void  *p_arg);
static  void  AppTaskCreate(void);
static  void  AppObjCreate (void);

static  void  Task_A(void *p_arg);
static  void  Task_B(void *p_arg);

/*
****************************************************
****************************************************
*
*                                                main()
*
* Description : This is the standard entry point for C code.  It is assumed that your code will call
*               main() once you have performed all necessary initialization.
*
* Arguments   : none
*
* Returns     : none
*
* Notes       : 1) STM32F7xx HAL library initialization:
*                      a) Configures the Flash prefetch, intruction and data caches.
*                      b) Configures the Systick to generate an interrupt. However, the function ,
*                         HAL_InitTick(), that initializes the Systick has been overwritten since Micrium's
*                         RTOS has its own Systick initialization and it is recommended to initialize the
*                         Systick after multitasking has started.
*
****************************************************
****************************************************
*
*/

int main(void)
{
    OS_ERR   err;
#if (CPU_CFG_NAME_EN == DEF_ENABLED)
    CPU_ERR  cpu_err;
#endif

    HAL_Init();                                                 /* 初始化HAL库                                          */

    Mem_Init();                                                 /* 初始化内存管理模块                                   */
    Math_Init();                                                /* 初始化数学算法模块（生成随机数种子）                 */

#if (CPU_CFG_NAME_EN == DEF_ENABLED)
    CPU_NameSet((CPU_CHAR *)"STM32F746xx",
                (CPU_ERR  *)&cpu_err);
#endif

    BSP_IntDisAll();                                            /* 关闭中断                                             */

    OSInit(&err);                                               /* 初始化uC/OS-III                                      */
    App_OS_SetAllHooks();

    OSTaskCreate(&AppTaskStartTCB,                              /* 创建启动进程                                         */
                  "App Task Start",
                  AppTaskStart,
                  0u,
                  APP_CFG_TASK_START_PRIO,
                 &AppTaskStartStk[0u],
                  AppTaskStartStk[APP_CFG_TASK_START_STK_SIZE / 10u],
                  APP_CFG_TASK_START_STK_SIZE,
                  0u,
                  0u,
                  0u,
                 (OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
                 &err);

    OSStart(&err);                                              /* 开启uC/OS-III                                        */

    while (DEF_ON) {                                            /* Should Never Get Here.                               */
        ;
    }
}


/*
****************************************************
****************************************************
*
*                                          STARTUP TASK
*
* Description : This is an example of a startup task.  As mentioned in the book's text, you MUST
*               initialize the ticker only once multitasking has started.
*
* Arguments   : p_arg   is the argument passed to 'AppTaskStart()' by 'OSTaskCreate()'.
*
* Returns     : none
*
* Notes       : 1) The first line of code is used to prevent a compiler warning because 'p_arg' is not
*                  used.  The compiler should not generate any code for this statement.
****************************************************
****************************************************
*
*/

static  void  AppTaskStart (void *p_arg)
{
    OS_ERR      err;
    CPU_INT32U  r0;
    CPU_INT32U  r1;
    CPU_INT32U  r2;
    CPU_INT32U  r3;
    CPU_INT32U  r4;
    CPU_INT32U  r5;
    CPU_INT32U  r6;
    CPU_INT32U  r7;
    CPU_INT32U  r8;
    CPU_INT32U  r9;
    CPU_INT32U  r10;
    CPU_INT32U  r11;
    CPU_INT32U  r12;


   (void)p_arg;

    r0  =  0u;                                                  /* Initialize local variables.                          */
    r1  =  1u;
    r2  =  2u;
    r3  =  3u;
    r4  =  4u;
    r5  =  5u;
    r6  =  6u;
    r7  =  7u;
    r8  =  8u;
    r9  =  9u;
    r10 = 10u;
    r11 = 11u;
    r12 = 12u;

    BSP_Init();                                                 /* 初始化板级支持包                                     */
    CPU_Init();                                                 /* 初始化CPU模块                                        */

#if OS_CFG_STAT_TASK_EN > 0u
    OSStatTaskCPUUsageInit(&err);                               /* Compute CPU capacity with no task running            */
#endif

#ifdef CPU_CFG_INT_DIS_MEAS_EN
    CPU_IntDisMeasMaxCurReset();
#endif

		UART_Config();
		
		/* Initialize LCD Communication for Application ...  		*/
		BSP_LCD_Config();
    APP_TRACE_DBG(("Creating Application kernel objects\r\n"));
		AppObjCreate();                                             /* 创建任务通信过程中使用的信号量等对象                 */

    APP_TRACE_DBG(("Creating Application Tasks\r\n"));
    AppTaskCreate();                                            /* 创建应用任务                                         */

    BSP_LED_Off(LED1);

    while (DEF_TRUE) {                                          /* 启动任务进入无限循环                                 */
        OSTimeDlyHMSM(0u, 0u, 0u, 100u,
                      OS_OPT_TIME_HMSM_STRICT,
                      &err);

        if ((r0  !=  0u) ||                                     /* Check task context.                                  */
            (r1  !=  1u) ||
            (r2  !=  2u) ||
            (r3  !=  3u) ||
            (r4  !=  4u) ||
            (r5  !=  5u) ||
            (r6  !=  6u) ||
            (r7  !=  7u) ||
            (r8  !=  8u) ||
            (r9  !=  9u) ||
            (r10 != 10u) ||
            (r11 != 11u) ||
            (r12 != 12u)) {
           APP_TRACE_INFO(("Context Error\r\n"));
        }
    }
}

/*
****************************************************
****************************************************
*
*                                          AppTaskCreate()
*
* Description : Create Application Tasks.
*
* Argument(s) : none
*
* Return(s)   : none
*
* Caller(s)   : AppTaskStart()
*
* Note(s)     : 该任务创建应用任务
****************************************************
****************************************************
*
*/

static  void  AppTaskCreate (void)
{
    OS_ERR  os_err;

/* ---------- 创建应用任务 --------- */
    OSTaskCreate(&Task_ATCB,
                 "Kernel Objects Task A",
                  Task_A,
                  0,
                  APP_CFG_TASK_OBJ_PRIO,
                 &Task_AStk[0],
                  Task_AStk[APP_CFG_TASK_OBJ_STK_SIZE / 10u],
                  APP_CFG_TASK_OBJ_STK_SIZE,
                  0u,
                  0u,
                  0,
                 (OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
                 &os_err);

    OSTaskCreate(&Task_BTCB,
                 "Kernel Objects Task B",
                  Task_B,
                  0,
                  APP_CFG_TASK_OBJ_PRIO,
                 &Task_BStk[0],
                  Task_BStk[APP_CFG_TASK_OBJ_STK_SIZE / 10u],
                  APP_CFG_TASK_OBJ_STK_SIZE,
                  0u,
                  0u,
                  0,
                 (OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR),
                 &os_err);
}

/*
****************************************************
****************************************************
*
*                                          AppObjCreate()
*
* Description : Create Application Kernel Objects.
*
* Argument(s) : none
*
* Return(s)   : none
*
* Caller(s)   : AppTaskStart()
*
* Note(s)     : 该任务创建任务通信过程中使用的信号量。
****************************************************
****************************************************
*
*/
static  void  AppObjCreate (void)
{
    OS_ERR  os_err;

#if (OS_CFG_SEM_EN > 0u)
    OSSemCreate(&wait_key_sem,
                "Key Detection",
                 0u,
                &os_err);
    OSSemCreate(&wait_key_sem2,"Key Detection",0u,&os_err);
#endif
}

/*
****************************************************
****************************************************
*
*                                          Task_A()
*
* Description : Test uC/OS-III objects.
*
* Argument(s) : p_arg is the argument passed to 'Task_A' by 'OSTaskCreate()'.
*
* Return(s)   : none
*
* Caller(s)   : This is a task
*
* Note(s)     : 该任务检测S3是否被按下并释放，当S3释放时向Task_B发送信号量。
****************************************************
****************************************************
*
*/
void Task_A(void *p_arg)
{	   
	OS_ERR  err;
	unsigned char key_press = 0;

	while(DEF_TRUE)
	{
	// 	OSTimeDly(30, OS_OPT_TIME_DLY, &err);
    // if (BSP_PB_GetState(BUTTON_TAMPER) == RESET)
	// 		key_press = 1;
	// 	if (BSP_PB_GetState(BUTTON_TAMPER) == SET)
	// 	{
	// 		if(key_press == 1)
	// 		{
	// 			key_press = 0;
	// 			OSSemPost(&wait_key_sem, OS_OPT_POST_1, &err);
	// 		}
	// 	}	
        OSTimeDly(60, OS_OPT_TIME_DLY, &err);
				if (BSP_PB_GetState(BUTTON_TAMPER) == RESET){
            OSSemPost(&wait_key_sem, OS_OPT_POST_1, &err);
        }
	}
}
/*
****************************************************
****************************************************
*
*                                          Task_B()
*
* Description : Test uC/OS-III objects.
*
* Argument(s) : p_arg is the argument passed to 'Task_B' by 'OSTaskCreate()'.
*
* Return(s)   : none
*
* Caller(s)   : This is a task
*
* Note(s)     : 该任务等待Task_A发送来的信号量，当获取到信号量时点亮/熄灭LED1并向串口发送数据。
****************************************************
****************************************************
*
*/
void Task_B(void *p_arg)
{			  
	OS_ERR  err;
	CPU_TS  ts;

	while(DEF_TRUE)
	{
		OSTimeDly(30, OS_OPT_TIME_DLY, &err);
		OSSemPend(&wait_key_sem,
                  0,
                  OS_OPT_PEND_BLOCKING,
                  &ts,
                  &err);
		BSP_LED_Toggle(LED1);	//Toggle after key release
        OSTimeDly(30, OS_OPT_TIME_DLY, &err);
        BSP_LED_Toggle(LED1);
		APP_TRACE_DBG(("Get a Semaphore from Task A\n\r"));
	}
}


\end{lstlisting}


\end{document}
