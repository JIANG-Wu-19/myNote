## 第三次作业

### SUB R3，R2，R1，LSR R0 写出上面指令的32位编码，并说明每一位（或几位）的含义。

| 指令编码（从高位到低位） | 位数  |                     含义                     |
| :----------------------: | :---: | :------------------------------------------: |
|           1110           | 31-28 | 条件位，为默认值AL，表示任何时候都执行本指令 |
|           000            | 27-25 |                      -                       |
|           未知           | 24-21 |                  SUB操作码                   |
|            0             |  20   |             不影响CPSR寄存器的值             |
|           0010           | 19-16 |            第一个操作数的寄存器R2            |
|           0011           | 15-12 |                 目标寄存器R3                 |
|          00000           | 11-7  |            左移位数的存放寄存器R0            |
|            01            |  6-5  |                 LSR逻辑右移                  |
|            0             |   4   |                      -                       |
|           0001           |  3-0  |            第二个操作数的寄存器R1            |

### 读程序，给每一行增加注释，并说明执行过程中R0,R1,R2的值如何变化

```assembly
AREA StrCopy, CODE, READONLY ; 定义代码区域，不可修改，只可读
ENTRY            ; 指定程序的入口点
start            ; 程序入口

X EQU 88           ; 定义符号常量X为88
Y EQU 76           ; 定义符号常量Y为76
Z EQU 96           ; 定义符号常量Z为96

STACK_TOP EQU 0X1000     ; 定义符号常量STACK_TOP为0X1000
  MOV R0, #0XAB      ; 把0XAB的值加载到寄存器R0中，R0=0xAB
LOOP1
  MOV R0, R0, ASR #1    ; 把R0右移一位，并把结果存回R0，R0=0x55，第二次执行该语句时变为R0=0x2A
  CMP R0, #0X50      ; 比较R0与0X50的大小
  BGE LOOP1        ; 如果R0大于等于0X50则跳转到LOOP1标记处（此处会跳转）
  MOV R1, #Y        ; 把Y的值加载到寄存器R1中，R1=76=0x4C
  ADD R2, R0, R1, LSL #1  ; 把R0和R1左移一位的结果相加，存入R2中, R2=R0+R1*2=0xC2
  MOV SP, #0X1000     ; 把0X1000的值加载到栈指针寄存器SP中
  STR R2, [SP]       ; 把R2的值存入以栈指针寄存器SP的值为地址的存储单元中
  MOV R0, #Z        ; 把Z的值加载到寄存器R0中,R0=96=0x60
  AND R0, R0, #0XFF    ; 把R0与0XFF进行与运算，存入R0中, R0=0x60
  MOV R1, #Y        ; 把Y的值加载到寄存器R1中,R1=76=0x4C
  ADD R2, R0, R1, LSR #1  ; 把R0和R1右移一位的结果相加，存入R2中,R2=R0+R1/2=0x86
  LDR R0, [SP]       ; 将以栈指针寄存器SP的值为地址的存储单元中的内容加载到寄存器R0中,R0=0xC2
  MOV R1, #0X01      ; 把0X01的值加载到寄存器R1中，R1=0x01
  ORR R0, R0, R1      ; 把R0和R1进行或运算，存入R0中,R0=0xC3
  MOV R1, R2        ; 把R2的值加载到寄存器R1中,R1=0x86
  ADD R2, R0, R1, LSR #1  ; 把R0和R1右移一位的结果相加，存入R2中,R2=R0+R1/2=0x106
STOP
  B STOP          ; 无条件跳转到STOP标记处，即进入死循环
END
```

LOOP1执行两次循环，直到R0=0x2A<0x50

R1=0x4C

R2=R0+R1*2=0xC2

R0=0x60

R1=0x4C

R2=R0+R1/2=0x86

R0=0xC2

R1=0x01

R0=0xC3

R1=0x86

R2=R0+R1/2=0x106

程序最终运行结果为：R0=0xC3, R1=0x86, R2=0x106

