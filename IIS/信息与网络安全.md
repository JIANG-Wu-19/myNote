# 信息与网络安全

## 概论

### 网络安全威胁

* 恶意软件
* 安全性破坏
* DoS攻击

### 信息与网络安全目标

三个关键目标：

* 机密性
  * 数据机密性
  * 隐私性
* 完整性
  * 数据完整性
  * 系统完整性
* 可用性

### TCP/IP安全服务模型

![image-20230915101220938](imgs\1.png)

### 网络攻击

* 主动攻击
  * 伪装
  * 重放
  * 篡改
  * 拒绝服务
* 被动攻击
  * 窃听攻击
  * 流量分析

### 五类安全服务

* 认证
* 访问控制
* 保密
* 完整性
* 不可否认

### 八类安全机制

![image-20230915102412545](imgs\2.png)

## 数据加密技术

### 数据加密技术概述

* 密码学
* 加密系统
* 密码分析
* 加密
* 明文
* 密文
* 密钥

#### 对称密码和公钥密码

* 对称密码
  * 密钥：加密和解密密钥相同或可相互推导
  * 优点：加密速度快
  * 缺点：密钥管理复杂
* 公钥密码
  * 密钥：公钥与私钥不同且难以用私钥推导公钥
  * 优点：密钥管理简单
  * 缺点：加密速度慢

#### 对称密钥

加密和解密使用的是同样的密钥

#### 公开密钥

* 加密和解密的密钥不同
* 密钥分为公钥、私钥

#### 密码学基本原则之一

* Kerckhoffs原则：密码系统是安全的，表明可以公开除了密钥之外的整个密码系统的一切内容
* 密码系统的内部工作原理对于攻击者完全公开，唯一秘密是密钥

维护密钥成本低于维护密码算法

### 经典加密

#### 简单替换密码

改进：非常规字母表替换

破解方法一：穷举式密钥检索

破解方法二：统计字母频率

#### 双换位密码

#### 一次性密码本

$明文 \oplus 密钥=密文$

### 对称密钥加密

#### 对称密钥加密的分类

* 流密码加密—类似于一次性密码本
  * 密钥较短
  * 密钥延展成长二进制码流
  * 类似一次性密码本
* 分组密码加密—类似于电报密码本
  * 密钥决定密码本的选择
  * 电报密码本的电子版本
  * 扰乱和扩散的两个原则

#### 流密码加密

![image-20231008111905960](imgs/3.png)

用n位长度的密钥K，并将其延展成长长的密钥流，然后该密钥流与明文P进行异或运算，生成密文C。接收方再用同样的方法解密

* A5/1算法
  * A5 / 1是用于在GSM蜂窝电话标准中提供无线通信隐私的流密码算法。
  * A5 / 1算法使用三个线性反馈移位寄存器：
    * X: 19 bits (x0,x1,x2, …,x18)
    * Y: 22 bits (y0,y1,y2, …,y21)
    * Z: 23 bits (z0,z1,z2, …,z22)
  * A5/1算法的密钥K共64位，用于三个线性反馈移位寄存器的初始填充，充当三个寄存器的初始值
  * 三个寄存器用密钥填充之后，就可以开始滚动生成密钥流了。每个回合可以拆分为三个步骤：
    * 反馈多项式（Feedback Polynomial）
      * 这里使用的是择多原则，三个寄存器中各选择一个钟控信号，19位寄存器中为第8位，22位、23位寄存器中皆为第10位。
      * 根据这三个钟控信号的取值，必定有0或1数量居多，居多的寄存器需要进行位移操作。
    * 位移
      * $m=maj(x_8,y_{10},z_{10})$
      * 需要移位的寄存器向右移位，将t填入空出来的第0位
      * if $x_8=m$，X右移，$t=x_{13} \oplus x_{16} \oplus x_{17} \oplus x_{18}$
      * if $y_{10}=m$，Y右移，$t=y_{20} \oplus y_{21}$
      * if $z_{10}=m$，Z右移，$t=z_7 \oplus z_{20} \oplus z_{21} \oplus z_{22}$
    * 取KEY
      * 取三个寄存器的最后一位，也就是19位、22位、23位，进行异或操作，得到的结果为这一轮密钥流的一位:$Keystream bit=x_{18} \oplus y_{21} \oplus z_{22}$

#### 分组密码加密

* 将明文分割成**固定长度**的分组，并生成固定长度的密文分组；
* 密文都是通过“用函数F对明文进行若干轮的**迭代**计算”得到的；
* 函数F：依赖于前一轮计算的输出和密钥K，称为**轮函数**；
* 一般用**软件**实现

##### Feistel密码

* 明文分组P被分割成左右两部分，$P=(L_0,R_0)$
* 对于每一轮i，i=1,2,3,…,n
  * $L_i=R_{i-1}$
  * $R_i=L_{i-1} \oplus F(R_{i-1},K_i)$
* 密文：$C=(L_n,R_n)$
* 解密
  * $C=(L_n,R_n)$
  * $R_{i-1}=L_i$
  * $L_{i-1}=R_i \oplus F(R_{i-1},K_i)$
  * $P=(L_0,R_0)$

![image-20231016194440635](imgs/4.png)

##### DES

* 1970年代

* 基于IBM的Lucifer 密码

* 其争议性

  * NSA密码参与；

  * 设计过程保密；
  * 密钥长度从128位降到56位；
  * 对Lucifer 进行了一些修改。

原理

* 使用一个56 位的密钥以及附加的8 位奇偶校验位，产生最大64 位的分组大小；
* 使用Feistel技术，将加密的文本块分成两半;
* 用子密钥对其中一半应用循环功能，然后将输出与另一半进行“异或”运算；
* 接着交换这两半，这一过程会继续下去，但最后一个循环不交换。
* DES 使用16 个循环，使用异或，置换，代换，移位操作四种基本运算。
* S-box起到重要作用，每一个S-box将6个二进制位映射到4个二进制位。

![image-20231016194723854](imgs/5.png)

![image-20231016195055394](imgs/6.png)

![image-20231016195201337](imgs/7.png)

![image-20231016195247933](imgs/8.png)

##### AES

* 替代DES;
* 迭代式分组加密;
* 没有采用Feistel结构;
* 分组大小为128位;
* 三种密钥长度：128，192，256
* 依照密钥长度不同，运算轮次从10轮至14轮不等
* 每轮包含4个函数，分为3个层次
  * ByteSub(非线性层)
  * ShiftRow(线性混合层)
  * MixColumn(非线性层)
  * AddRoundKey(密钥添加层)

![image-20231016201355735](imgs/9.png)

* 行移位

![image-20231016201510542](imgs/10.png)

![image-20231016201604209](imgs/11.png)

* 轮密钥合并

![image-20231016201635295](imgs/12.png)

### 公开密钥加密

对称密钥带来的问题：

* 密钥不能公开；
* 如何安全地交换密钥
* 如何确认发送者身份

需要解决：

* 可靠密钥的传输通道问题
* 如何提供与手写签名等效的认证体系

#### 公钥加密算法

* 公钥加密算法使用两把完全不同但又是完全匹配的一对钥匙—公钥和私钥。
* 加密明文时采用公钥加密。
* 解密密文时使用私钥才能完成，只有使用匹配的一对公钥和私钥，才能完成加密和解密过程。

**公开的密钥为公钥**

**不公开的密钥为私钥**

![image-20231016202349985](imgs/13.png)

##### 公钥加密

* 两个密钥：
  * 公钥：可为任何人知道，用来加密消息或者验证签名;
  * 私钥：只有接收者本人知道，用来解密消息和签名。
* 不对称性：
  * 用来加密消息的密钥不能用来解密消息

![image-20231016202822051](imgs/14.png)

##### 公钥密码系统的加密原理

* 每个通信实体有一对密钥（公钥，私钥）。公钥公开，用于加密和验证签名，私钥保密，用作解密和签名
* A向B 发送消息，用B的公钥加密
* B收到密文后，用自己的私钥解密
* 任何人向B发送信息都可以使用同一个密钥（B的公钥）加密,没有其他人可以得到B的私钥，所以只有B可以解密

![image-20231016210442978](imgs/15.png)

#### 通讯方式

##### 第一回合

* 正常情况
  * “客户”->“服务器”：你好；
  * “服务器”->“客户”：你好，我是服务器；
  * “客户”->“服务器”：我的密码是……
* 黑客入侵
  * “客户”->“服务器”：你好；
  * 黑客在“客户”和“服务器”之间的某个路由器上截获“客户”发给服务器的信息，然后自己冒充“服务器”；
  * “黑客”->“客户”：你好，我是服务器；
  * “客户”->“黑客”：我的密码是……

##### 第二回合

* “客户”->“服务器”：你好；
* “黑客”->“客户”：你好，我是服务器；
* “客户”->“黑客”：向我证明你就是服务器；
* “黑客”->“客户”：你好，我是服务器{你好，我是服务器}[？？？|RSA]。
* 黑客无法冒充，因为他不知道服务器的私钥，无法加密某个字符串后发送给客户去验证。
* “客户”：有内鬼，终止交易！

##### 第三回合

* “客户”->“服务器”：你好
* “服务器”->“客户”：你好，我是服务器
* “客户”->“服务器”：向我证明你就是服务器
* “服务器”->“客户”：你好，我是服务器{你好，我是服务器}[私钥|RSA]
* “客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]
* “服务器”->“客户”：{你的余额是100元}[私钥|RSA]

##### 第四回合

* “客户”->“服务器”：你好
* “服务器”->“客户”：你好，我是服务器
* “客户”->“服务器”：向我证明你就是服务器
* “服务器”->“客户”：你好，我是服务器{你好，我是服务器}[私钥|RSA]
* “客户”->“服务器”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA]
* //红色字体的部分是对称加密的算法和密钥的具体内容，客户把它们发送给服务器。
* “服务器”->“客户”：{OK，收到！}[密钥|对称加密算法]
* “客户”->“服务器”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]
* “服务器”->“客户”：{你的余额是100元}[密钥|对称加密算法]

#### 补充数学概念

##### 同余式

同余式是数论的基本概念之一，设m是给定的一个正整数，a、b是整数，若满足$m|(a-b)$，则称a与b对模m同余，记为$a \equiv b(\mod m)$，这个式子称为模m的同余式。

$m|(a-b)$表示m能够整除(a-b)，即$a \mod m=b \mod m$

##### 欧拉函数

欧拉函数$\varphi (n)$是小于等于n的正整数中与n互质的数的个数

对于任意互质的a和n，有$a^{\varphi (n)}\equiv 1(\mod n)$，即$a^{\varphi (n)} \mod n =1$

如果n是质数，则$\varphi (n) =n-1$，因为质数与小于它的每一个正整数都互质

如果$n=p*q$，而p和q互质，则：

$\varphi (n)=\varphi(p*q)=\varphi(p)*\varphi(q)=(p-1)(q-1)$

#### RSA

* 生成公钥/私钥对
  1. 取两个大素数p, q ($p \neq q$), 保密;
  2. 计算$n=p*q$，公开n;
  3. 计算欧拉函数$\varphi (n)=(p-1)(q-1)$；
  4. 随机选择整数e($1 \lt e \lt \varphi(n)$)，使得e和$\varphi(n)$互质即两个数的最大公约数为1；
  5. 计算d,使得$ed= 1(\mod \varphi(n))$，也就是$ed=k\varphi(n)+1$；
  6. 公开$(e,n)=(5,119)$；
  7. 将d保密，丢弃p,q
  
  $$
  m^{k(p-1)(q-1)+1} \equiv m(\mod n)
  $$
  
  $$
  m^{ed} \equiv m(\mod n)
  $$
  
* 加密消息$m$

  * 获取接收者的公钥：$K_u=\lbrace e,n \rbrace$
  * 计算：$c=m^e \mod n(0 \le m \le n)$

* 解密密文$c$

  * 使用自己的私钥：$K_R=\lbrace d,n \rbrace$
  * 计算：$m=c^d \mod n$

#### Diffie Hellman密钥交换方案

使两个用户安全地交换一个密钥以便用于以后的报文加密，这个算法本身限于**密钥交换**的用途

在Diffie-Hellman密钥交换算法中单项函数是模指数运算。它的逆过程是离散对数问题，其Diffie-Hellman算法的保密性基于求mod P解离散对数问题的困难

##### 本原元

定义素数g的本原元（primitive root）为其乘方能够产生从1到g-1的所有整数的数。也就是说，如果n是素数g的本原元，那么有下列数字：
$$
n \mod g,n^2 \mod g,n^{g-1} \mod g 
$$
这g−1个数字互不相同，而且包含了从1到g−1的所有整数

##### 离散对数

对于任何小于g的整数a和素数g的本原元n来说，能够找到唯一的指数i满足：
$$
a=b^i \mod g ,0 \le i \le (g-1)
$$
称指数i为a对于基数n和运算mod g 的离散对数

##### 密钥原理

设$g$是一个质数，$n$是$g$的本原元，要求$n$和$g$是公开的，则网络中的某一用户可以任选一个小于$g$的整数$a$作为秘密密钥

![image-20231020104322307](imgs/16.png)

#### 椭圆曲线加密ECC

##### 椭圆曲线

已知椭圆曲线群
$$
E_p(a,b):y^2=x^3+ax+b,4a^3+27b^2 \neq 0
$$
**加法**

过曲线上的两点A、B画一条直线，找到直线与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A+B，即为加法。

![image-20231020110318344](imgs/17.png)

**取反**

将A关于x轴对称位置的点定义为-A，即椭圆曲线的正负取反运算

![image-20231020110352306](imgs/18.png)

**二倍运算**

将过椭圆曲线在A点的切线，与椭圆曲线的交点，交点关于x轴对称位置的点，定义为A + A，即2A，即为二倍运算。

![image-20231020110617599](imgs/19.png)

**无穷远点**

如果将A与-A相加，过A与-A的直线平行于y轴，可以认为直线与椭圆曲线相交于无穷远点



**有限域上的椭圆曲线**

已知有限域$GF(p)(p=q^n,q>3)$上的椭圆曲线群：
$$
E_p(a,b):y^2=x^3+ax+b(\mod p)
$$
有限域GF(p)指给定某个质数p，由0、1、2......p-1共p个元素组成的整数集合中定义的加减乘除运算

**有限域$GF(p)$**

Fp中有p（p为质数）个元素0,1,2,…, p-2,p-1

加法：$a+b \equiv c(\mod p)$

乘法：$a \times b \equiv c(\mod p)$

除法：$a/b \equiv c(\mod p)$

Fp单位元是1，零元是0

满足交换律、结合律、分配律

##### 加密原理

在定义了这一系列运算之后，我们可以很容易的计算出给定的G点对应的2G，3G等点。即：当给定G点时，已知x，求xG点并不困难。反之，已知xG点，求x则非常困难。此即为椭圆曲线加密算法背后的数学原理。

##### 计算及求解

计算椭圆曲线$y^2=x^3+ax+b(\mod p)$两点P，Q的和
$$
\left\{\begin{array}{c}
\mathrm{y}^2=\mathrm{x}^3+\mathrm{ax}+\mathrm{b}(\bmod \mathrm{p}) \\
\mathrm{y}-\mathrm{y}_{\mathrm{p}}=k\left(x-x_p\right) \\
k=\frac{y_q-y_p}{x_q-x_p}
\end{array}\right.
$$
计算过椭圆曲线点P的二倍点R
$$
\left\{\begin{array}{c}
x_r=\left(\frac{3 \mathrm{x}_{\mathrm{p}}^2+\mathrm{a}}{2 \mathrm{y}_{\mathrm{p}}}\right)^2-2 x_p \\
y_r=\left(\frac{3 \mathrm{x}_{\mathrm{p}}^2+\mathrm{a}}{2 \mathrm{y}_{\mathrm{p}}}\right)\left(x_p-x_r\right)-y_p
\end{array}\right.
$$

##### 准备工作

* 约定：选取$E_p(a,b)$和生成元$G$，公开
* 密钥的生成：选取私钥d,公钥为$e=dG$

##### 加密过程

* 将明文消息m通过编码嵌入到曲线上的点Pm
* 随机选取数字k，将密文$C_m=\lbrace kG,Pm+ke \rbrace$发送

##### 解密过程

* 收到密文$C_m=\lbrace kG,Pm+ke \rbrace$
* 利用自己的密钥d，计算$(Pm+ke)-dkG=Pm$

![image-20231020112343650](imgs/20.png)

## 消息认证及数字签名

消息认证是一种允许通信者验证所收消息是否可信的措施，用于确认：

* 内容是否篡改
* 来源是否可信

### 消息认证方法

#### 散列函数

* 散列函数是一种创建数字“指纹”的方法。它把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来
* 与消息认证码（MAC）不同的是散列函数不需要密钥输入

**变长消息->散列函数->定长摘要**

##### 单向散列函数消息认证的三种方式

###### 使用传统加密

![image-20231020113334053](imgs/21.png)

###### 使用公钥加密

![image-20231020113407576](imgs/22.png)

###### 使用秘密值

![image-20231020113609124](imgs/23.png)

* 加密的散列函数，满足以下所有条件

  * 抗弱碰撞性：给定x和h(x)，要想找到任意y，满足$y \neq x$，并且h(y)=h(x)，这是不可能的
  * 抗强碰撞性：要想找到任意的x和y，使得$x \neq y$，并且h(y)=h(x)，这是不可能的

* 散列函数的工作模式

  ![image-20231021171814550](imgs/24.png)

* 主流算法：MD5,SHA-1,SHA-2,Tiger Hash

##### MD5算法

![image-20231021171938372](imgs/25.png)

MD5算法以一个任意长度的消息（M）作为输入，生成128位（16字节）的消息摘要作为输出，输入消息是按512位的分组处理的

![image-20231021172013971](imgs/26.png)

#### 消息认证码

消息验证码是利用私钥产生的一小块数据，将其附到消息上，用来进行消息验证

消息认证码和散列函数区别：散列函数不需要加密，而**消息认证码是需要加密的**

假设两个通信实体（如A和B）共享一个公共密钥Kab

* 当A发消息M给B时，A计算消息认证码$MAC=F(K_{ab},M)$，并将MAC和消息一起传送给B。
* B对接收到的消息使用密钥Kab做相同运算，生成新的MAC。比较收到的MAC和计算得到的MAC

![image-20231021174421706](imgs/27.png)

假设只有接收者和发送者知道密钥，若收到的认证码与计算得到的认证码相吻合，则可得出下列结论：

1. 接收者能够确认消息没有被篡改
2. 接收者能够确保消息来自合法的发送者
3. 如果消息中包含序列号，而攻击者不能成功地修改序列号，那么接收者就可以确认消息的正确序列

##### 基于散列函数消息认证码-HMAC

* 不改动就可以使用散列函数
* 嵌入式散列函数要有很好的可移植性
* 保持散列函数原有性能，不发生显著退化
* 使用和处理密钥简单

![image-20231021184403747](imgs/29.png)
$$
HMAC(K,M)=H[(K^+ \oplus opad)||H[(K^+ \oplus opad)||M]]
$$
算法：

1. 在K的左端追加0，构成b比特的字符串$K^+$；
2. Ipad与$K^+$进行XOR生成b比特的分组$S_i$；
3. 将M追加在$S_i$；
4. 将H应用于步骤(3)所产生的数据流；
5. opad与$K^+$进行XOR生成b比特的分组$S_o$；
6. 将步骤(4)产生的散列结果追加在$S_o$上；
7. 将H应用于步骤6产生的数据流，输出结果；

##### 基于分组密码的MAC—CMAC

* 当消息长度是分组长度的整数倍时

  ![image-20231021185226675](imgs/30.png)

* 当消息长度不是分组长度的整数倍时

  ![image-20231021185259659](imgs/31.png)

![image-20231021185416402](imgs/32.png)

### 数字签名技术

数字签名是**只有信息的发送者才能产生的别人无法伪造的一段数字串**，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。它是一种类似写在纸上的普通的物理签名，但是在使用了公钥加密领域的技术来实现的，用于鉴别数字信息的方法

要求：

* 发方发出签名后的消息，就不能否认所签消息
* 收方能确认或证实发方的签字，但不能伪造
* 收方对已收到的消息不能否认
* 第三者可以确认收发双方之间的消息传送，但不能伪造这一过程

应具有：

* 必须能够验证签名者及其签名的日期时间
* 必须能够认证被签名消息的内容
* 签名必须能够由第三方验证，以解决争议

两类数字签名函数

* 直接数字签名
  * 仅涉及通信双方
  * 有效性依赖发方密钥的安全性
* 仲裁数字签名
  * 使用第三方认证

两种加密方法：

**利用发送方的私钥加密**

![image-20231021190603255](imgs/33.png)

![image-20231021190751442](imgs/35.png)

**利用发送方的私钥报文散列码加密**

![image-20231021190653079](imgs/34.png)

![image-20231021190822679](imgs/36.png)







