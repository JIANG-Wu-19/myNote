# 软件工程

《软件工程原理》沈备军

项目实践：软件逆向工程

## 软件危机与软件工程

### 软件危机

问题

* 如何开发软件以满足不断增长
* 如何维护数量不断膨胀的软件产品

表现

* 成本超预算，上线拖延
* 偏离用户需求
* 质量不够
* 可维护度低
* 没有适当文档
* 成本提高
* 供不应求

原因

* 软件本身特点
* 软件开发错误认识做法
* 开发维护的不正确

## 软件过程

软件生存周期过程

### 软件过程七大元素

* 活动

  开发、维护、管理

* 任务

  活动细分，确定、安排任务

* 工件

  软件过程的工作产品，分输入与输出工作

* 角色

  定义软件过程中的个人或小组的行为与职责

* 资源

  最佳实践、工具、技术、机器、场地等

* 目标

  每个过程有明确目标

* 度量指标

  目标的具体度量与分析：进度、成本、质量、返工率

### 软件生存周期模型

* 线性顺序模型

  瀑布模型

  特点：

  * 强调阶段的划分顺序与依赖；
  * 强调各阶段工作文档的完备性，即文档驱动静态描述；
  * 每个阶段从技术和管理进行严格的审查，即质量保证的
    观点；
  * 是一种线性的、顺序的、逐步细化的开发模式；
  * 推迟实现的观点；

  适用时机：

  * 所有功能、性能等要求能一次理解和描述时
  * 所有的系统功能一次交付时
  * 必须同时淘汰全部老系统时

  实际的瀑布模型具有**反馈环**

  风险缺点：

  * 获得完善的需求规约是非常困难的；
  * 难以适应快速变化需求；
  * 系统太大时,难以一次做完；
  * 反馈信息慢；
  * 极可能引起开发后期的大量返工，如返工到需求、设计等早
    期活动；

  建议不适用的情况：

  ![image-20230914085603259](img/1.png)

* 增量式模型

  软件被分解成许多增量构件，逐个提交

  构造中间版本

  ![image-20230914085943130](img/2.png)

  适用实际：

  * 需要早期获得功能；
  * 中间产品可以提供使用；
  * 系统被自然地分割成增量；
  * 工作人员/资金可以逐步增加。

  考虑风险：

  * 需求未被很好地理解
  * 一次要求所有功能
  * 需求迅速发生变化
  * 事先打算采用的技术迅速发生变化
  * 长时期内仅有有限的资源（人员/资金）

* 演化模型

  只要核心需求能够被很好地理解，就可以进行渐进式开发，其余需求可以在后续的迭代中进一步定义和实现。这种过程模型称为演化模型，它能很好地适应随时间演化的产品的开发。

  特点：

  * 迭代的开发方法，渐进地开发各个可执行版本，逐步完善软件产品。每个版本在开发时，开发过程中的活动和任务顺序地或部分重叠平行地被采用。
  
  * 与增量模型的区别是：需求在开发早期不能被完全了解和确定，在一部分被定义后开发就开始了，然后在每个相继的版本中逐步完善。
  
    ![image-20230921080755595](img/3.png)
  
  * 现代软件工程采用演化模型
  
    * 统一软件过程RUP
    * 敏捷过程
    * 净室软件过程
  
  * 演化模型的子类
  
    * 原型
    * 螺旋模型
    * 并发开发模型
  



### 演化模型

#### 迭代化开发

特点： 尽可能降低风险，适用处理不确定的复杂系统。
原则:

1. 每次迭代产生一个可执行的版本；
2. 要求有计划地迭代。

![image-20230921081712692](img/4.png)

##### 快速原型模型

特点：定义出总体目标或初步需求就开发原型，通过原型与用户交互识别进一步的需求.

1. 抛弃式原型
2. 演化式原型

![image-20230921081842792](img/5.png)

##### 螺旋模型

![image-20230921081928140](img/6.png)

#### RUP统一软件过程

1. 迭代式开发
2. 管理需求
3. 使用基于构件的体系结构
4. 可视化建模
5. 贯穿于开发过程的软件质量验证
6. 控制软件变更

![image-20230921082152709](img\7.png)

Best Practices
Process Made Practical
Develop Iteratively
Manage Requirements
Use Component Architectures
Model Visually (UML)
Continuously Verify Quality
Manage Change

##### RUP软件开发生命周期

![image-20230921082504263](img/8.png)

RUP是一个风险驱动的、基于UML和构件式架构的迭代、递增型开发过程

##### 阶段和迭代

![image-20230921082630957](img/9.png)

##### 6个核心规范和3个支持规范

RUP把软件开发生命周期分成6个核心规范和3个支持规范

###### 6个核心规范

* 业务建模(系统目标达成共识)
* 需求(系统范围达成共识)
* 设计
* 实现
* 测试
* 部署

###### 3个支持规范

* 配置与变更管理
* 项目管理(风险,计划,进度等)
* 环境

#### 敏捷过程与极限编程

##### 敏捷过程

具有高效、快速响应变化的开发过程

![image-20230921083304665](img/10.png)

动机：快速的市场进入时间、快速变化的需求、快速发展的技术

**敏捷宣言**

1. 个体和交互胜过过程和工具；
2. 可以工作的软件胜过面面俱到的文档；
3. 客户合作胜过合同谈判；
4. 响应变化胜过遵循计划。

敏捷过程的原则

* 优先目标是尽早持续交付高价值的软件来满足客户需求；
* 通过驾驭变化帮助客户赢得竞争；
* 经常交付可用软件；
* 业务员和开发人员必须每天一起工作；
* 以积极主动地人为核心建立项目团队；
* 可用软件是最主要的项目进展目标；
* 团队内外最有效的交流是面对面交流；
* 提倡可持续开发，保持稳定的工作步调；
* 用精益求精和优良设计增强敏捷性；
* 简约—工作最小化；
* 最优的架构、需求和设计来自自组织的团队；
* 团队不断开展工作反思，校正自身行为。

实践做法

* 敏捷过程很容易适应变化并迅速做出自我调整，在保证质量的前提下，实现企业效益的最大化
* 敏捷过程在保证软件开发有成功产出的前提下，尽量减少开发过程中的活动和制品，Just enough

适用范围

* 需求不确定、易挥发
* 有责任感和积极向上的开发人员
* 用户容易沟通并能参与
* 小于10个人的项目团队

##### 极限编程XP-敏捷软件工程实践

价值观

沟通、反馈、简化、勇气

特点

测试成为开发的核心;

纪律性与灵活性巧妙结合.

XP项目的整体开发过程

![image-20230921090250148](img/11.png)

![image-20230921090334703](img/12.png)

XP迭代开发过程

![image-20230921090521198](img/13.png)

![image-20230921090600558](img/14.png)

XP关键做法

* 现场客户（On-site Customer）
* 计划博弈（Planning Game）
* 系统隐喻（System Metaphor）
* 简化设计（Simple Design）
* 集体拥有代码（Collective Code Ownership）
* 结对编程（Pair Programming）
* 测试驱动（Test-driven）
* 小型发布（Small Releases）
* 重构（Refactoring）
* 持续集成（Continuousintegration）
* 每周40小时工作制（40-hour Weeks）
* 代码规范（Coding Standards）

##### RUP与XP共性

* 基础都是面向对象方法（取代传统的结构化方法）
* 都重视代码、文档的最小化和设计的简化
* 采用动态适应变化的演进式迭代周期（取代传统的瀑布型生命周期）
* 需求和测试驱动
* 鼓励用户积极参与

##### RUP与XP的区别

* XP以代码为中心，编码和设计活动融为一体，弱化了架构的概念。
* RUP过程通常以架构为中心，细化阶段的主要目的就是构造出一个可运行的架构原型，作为将来添加需求功能的稳固基础。
* XP不包含业务建模、部署、过程管理等概念。
* RUP适合各种规模的项目，XP只适用于小团队。

#### 微软过程

##### 微软过程准则

* 项目计划应该兼顾未来的不确定因素;
* 用有效的风险管理来减少不确定因素的影响;
* 经常生成并快速的地测试软件的过渡版本，提高稳定性和可预测性;
* 采用快速循环，递进的开发过程;
* 用创造性的工作来平衡产品特性和产品成本;
* 项目进度表应该具有较高稳定性和权威性;
* 使用小型项目组并发的完成开发工作;
* 在项目早期把软件配置项基线化，项目后期则冻结产品;
* 使用原型验证概念，对项目进行早期论证;
* 把零缺陷作为追求的目标;
* 里程碑评审会的目的是改进工作，切忌相互指责.

##### 微软软件生命周期

![image-20230921092829901](img/15.png)

##### 微软过程模型

![image-20230921093011743](img/16.png)

#### Scrum过程

* 强调经验性过程而不是确定性过程
* 演化型的迭代开发过程

![image-20230921093118096](img/17.png)

### 软件过程的选择与裁切

#### 软件过程的选择

1. 产品/项目自身的特点
2. 团队的实际情况和企业文化
3. 客户的影响

#### 软件过程进行裁剪

1. 流程归并与裁剪
2. 角色的筛选与定制
3. 工件的裁剪和定制

### 软件过程的评估与改进

#### 参考模型

1. CMM/CMMI

   过程能力成熟度模型

   CMMI是一个标准簇

   * CMMI4Development
   * CMMI4Svervice
   * CMMI4Acquisition

   CMMI模型不同的改进方法：

   * 组织成熟度方法（阶梯式模型）
   * 过程能力方法（连续式模型）

   ![image-20230921100418465](img/18.png)

   ![image-20230921100537595](img/19.png)

2. ISO/IEC 15504

   信息技术-软件过程评价标准，又称为SPICE

   ![image-20230921100651886](img/20.png)

3. ISO/IEC 20000

   用于评估和认证IT运维服务管理过程的能力

#### 软件过程的改进

![image-20230921100821461](img/21.png)

## 软件建模



## 需求工程

* 软件需求面临的挑战

1. 用户说不清需求；
2. 需求表达的二义性问题；
3. 需求经常变化, 项目没有时限；
4. 因误解或二义性的需求直到开发后期才发现；
5. 测试者没有明白产品要做什么；
6. 产品性能低、使用不方便等用户不满意；
7. 许多增强性需求未在需求获取阶段提出。

### 需求工程的概念

#### 软件需求 FURPS and FURPS+

功能性需求（F）与非功能性需求（URPS）

|      需求      |                             能力                             |                           具体要求                           |
| :------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| Functionality  |                   Feature Set,Capabilities                   |                     Generality,Security                      |
|   Usability    |                   Human Factors,Aesthetics                   |                  Consistency,Documentation                   |
|  Reliability   |         Frequency/Severity,of Failure,Recoverability         |                 Predictability,Accuracy,MTBF                 |
|  Performance   |               Speed,Efficiency,>Resource Usage               |                   Throughput,Response Time                   |
| Supportability | Testability,Extensibility,Adaptability,Maintainability,Compatibility | Configurability,Serviceability,Installability,Localizability,Robustness |

#### Functionality需求

功能、特性和安全性

* 概要功能需求
* 详细功能需求

#### Usablity需求

可用性

The ease with which software can be learned and
operated by the intended users

#### Reliability需求

软件在给定时间间隔内成功运行的概率

* 可靠性需求
  * 故障的频率
  * 可恢复性
  * 可预见性
  * 准确性
  * 平均失效间隔时间/平均无故障时间，MTBF

#### Performance需求

* 性能需求
  * 速度
  * 效率
  * 吞吐量
  * 响应时间
  * 容量
  * 资源利用情况

#### Supportability需求

支持性需求

* 可测试性
* 可扩展性
* 可适应性
* 可维护性
* 兼容性
* 可配置性
* 可服务性
* 可安装性
* 可本地化/国际化

#### FURPS+

* 设计约束（design constraints）：规定或约束了系统的设计的需求；
* 实现需求（implementation requirements） ：规定或约束了系统的编码或构建，如所需标准、编程语言、数据库完整性策略、资源限制和操作环境；
* 接口需求（interface requirements）：规定了系统必须与之交互操作的外部软件或硬件，以及对这种交互操作所使用的格式、时间或其他因素的约束；
* 物理需求（physical requirements.）：规定了系统必须具备的物理特征，可用来代表硬件要求，如物理网络配置需求。

#### 软件需求的三个层次

* 系统需求：业务/产品需求
* 项目干系人需求：原始需求
* 项目前景文档：概要需求
* 软件需求规约：详细需求

![image-20230928085813446](img/22.png)

### 需求获取

业务分析-〉确定系统边界-〉项目干系人交流-〉竞争产品观察-〉定义系统高层输入-〉形成前景文档

#### 前景文档--产品范围文档

1. 简介
2. 定位
   * 商机
   * 问题说明
   * 产品定位
3. 项目干系人和用户描述
4. 产品概述
5. 产品特性
6. 约束
7. 质量范围
8. 优先级
9. 其他产品需求
10. 文档需求

##### 分析问题及根源

##### 识别项目干系人

##### 识别项目的约束

##### 获取常用术语

##### 识别需求的来源

##### 收集需求

##### 产品定位

##### 撰写产品特性

##### 定义质量范围

##### 定义文档需求

##### 建立项目范围

##### 划分特性优先级

### 需求分析建模

#### 分析模型

需求分析的结果

与平台无关模型PIM

* 描述客户需求
* 建立软件设计基础
* 定义软件完成后可以被确认

##### 结构化分析模型

* 数据流图（DFD）
* 控制流图（CFD）
* 数据字典（DD）
* 实体—关系图（ERD）
* 状态转换图（STD）
* 加工说明（PSPEC）

##### 面向对象分析模型

* 用例图
* 活动图
* 类图
* 时序图、通信图
* 状态机图

#### 分析建模准则

* 必须描述并理解问题的信息域
  * 输入输出数据、永久性数据对象
* 必须确定软件所需要的功能
* 必须描述软件的行为
  * 受外部事件驱动的结果
* 模型必须能提以一种能提示层次化方式的分解
* 分析任务应该从本质信息向实现细节转移

### 需求定义和验证

定义需求、撰写需求文档（前景文档和详细的软件需求规约）

#### 软件前景文档

软件需求规约

作用：

作用：

* 项目管理的依据；
* 设计与实现的输入；
* 测试与质量保证的输入；

组成：

* 功能需求；
* 非功能性需求；
* 约束；

软件需求规约SRS定义了系统的外在行为和属性

统一软件过程UP提供的两个SRS需求模板

![image-20230928103723819](img/23.png)

![image-20230928103815246](img/24.png)

![image-20230928103906107](img/25.png)

#### 细化需求

* 细化功能需求
  * 引入分析模型
* 细化非功能需求
* 细化约束条件

#### 用户界面原型

* 也称“行为模型”，用来描述软件产品的行为，达到明确与细化需求的目的。
* 如果和用户交互，则需简要设计用户界面
  * 图纸（在纸上）
  * 位图（采用绘图工具），或可执行代码（交互式的电子界面原型）

#### 需求验证

##### 验证方面

1. 一致性

   所有需求必须是一致的，任何一条需求不能和其他需求互相矛盾

2. 完整性

   需求必须是完整的，规格说明书应该包括用户需要的每一个功能或性能

3. 现实性

   指定的需求应该是用现有的硬件技术和软件技术基本上可以实现的

4. 有效性

   必须证明需求是正确有效的，确实能解决用户面对的问题

##### 需求验证方法

* 原型确认

  * 抛弃型
  * 演进型

* 需求评审

  * 评审需求文档（Vision和SRS等），及时发现缺陷，寻找改进的契机，同时从评审反馈中获得知识，补充了正规的交流和培训机制，帮助团队建立对产品的共同理解

  * 评审过程

    准备计划-〉实施评审-〉返工-〉定稿签字

需求评审方法

* 审查
* 小组评审
* 走查
* 结对编程
* 同级桌查
* 轮查
* 临时评审

需求评审的输入输出

* 输入
  * 待评审的需求文档
  * Check list
* 输出
  * 评审结论
    * 通过
    * 有条件通过
    * 不通过
  * 缺陷清单

#### 需求管理

* 定义需求基线
* 需求跟踪
* 需求变更控制（建立新的需求基线）

##### 建立需求基线

通过对软件产品的特性和需求划分优先级来定义需求基线

##### 需求变更控制和版本控制

* 需求/范围变化的原因
  * 初期的认识不足导致错误或不完整的需求/范围
  * 需求/范围本身存在不一致
  * 业务变化导致的刚性需求/范围变更
  * 外部经济、市场环境的变化
  * 客户和项目组对已确认的需求/范围理解不一致
  * 技术制约或多目标权衡带来的需求/范围变更
* 需求变更策略
  * 以基线为核心统一变更控制过程
  * 建立项目变更管理小组
  * 未获批准不得擅自实施变更
  * 干系人和项目组成员应即时了解变更
  * 开发计划、设计测试代码的文档应及时更新
  * 采用需求变更控制工具

##### 需求跟踪

![image-20230928105944712](img/26.png)

## 结构化分析

### 结构化方法概述

一种面向数据流的传统软件开发方法

以数据流为中心构建软件的分析模型、设计模型和实现模型

* 结构化分析(Structured Analysis，简称SA)
* 结构化设计(Structured Design，简称SD)
* 结构化编程(Structured Programming，简称SP)

#### 结构化分析方法中的抽象与分解

随着分解层次的增加，抽象的级别越来越低，也越接近问题的解(算法和数据结构)

![image-20231007092853653](img/27.png)

#### 结构化分析模型

![image-20231007092941126](img/28.png)

* 数据字典是模型的核心，它包含了软件使用和产生所有数据的描述
* 数据流图：用于功能建模，描述系统的输入数据流如何经过一系列的加工变换逐步变换成系统的输出数据流
* 实体—关系图：用于数据建模，描述数据字典中数据之间的关系
* 状态转换图：用于行为建模，描述系统接收哪些外部事件，以及在外部事件的作用下的状态迁移情况

### 面向数据流的软件建模

#### 系统流程图

